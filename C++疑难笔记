---
title: C&C++疑难笔记
tags: C++,难点
grammar_cjkRuby: true
---


## C&C++的编译过程
编译过程主要分为4个过程  
1) **编译预处理**  预编译程序完成的工作，可以说成是对源程序的“替换”工作。经过这个过程，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。

> 宏定义命令；例如#define

> 条件编译指令；例如#ifdef
 
> 头文件包含指令；例如#include

> 特殊符号；例如__LINE__

> 预处理模块；例如#pragma

2) **编译、优化阶段**  通过词法分析、语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码或汇编代码。
在C++中，以下函数如果你没有定义但是被需要时，编译器会产生他们：默认构造函数、拷贝构造函数、析构函数、赋值运算符和一对取址运算符。

3) **汇编过程**   把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。

4) **链接程序**  将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。
CPP使用链接器以确保用到的函数都只被定义一次，以及确保static objects只被定义一次，会将我们做了声明但却未曾定义的函数检测出来。
链接有静态链接和动态链接。
C/C++编译过程 中，对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一 些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。

> **静态链接**：在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。

> **动态链接**：在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。备注：头文件里我们通常只放置声明而不是定义，因为头文件有可能被释放到多个源文件中，每个源文件都会单独编译，这样链接时就会发现全局空间中有多个定义了。

## 字符串字面量&字符字面量

``` cpp
char *ch=hello;
sizeof(ch);//指针，值为4
ch[1]='t';//error，不可更改

char ch[]="hello";
sizeof(ch);//数组，值为6
ch[1]='t';//OK，可以更改
```
当ch[]作为参数传递给函数时，ch退化为指针，此时sizeof(ch)＝4；

1)  字符串字面量是对象
C/C++ 中的对象（Object）指的是一块存储区。字符串字面量是不需要创建过程就可使用的对象，所以它既没有变量那样的声明或者定义（字符串字面量是无名对象），也不需要象动态分配的对象那样进行动态分配。由于这个原因，用来限定变量的类型限定符（如 const、volatile）以及存储类别指示符（如 extern、static、auto、register）不能用在修饰字符串字面量上。

2) 数组类型
字符串字面量是数组类型的对象，因而具有数组的一切特点。关于这一点在下面还会进一步说明。

3)  静态存储区
C/C++ 中对象的生存期按照其存储性质可分为三类：静态存储期（static storage duration）、自动存储期（automatic storage duration）以及动态存储期（dynamic storage duration）。相应地，对象可根据存储期性质分为静态对象、自动对象和动态对象三种。字符串字面量是静态对象，所以在程序运行期间会一直存在。

4) 字符串字面量是左值，而且是不可被更改的左值。
例如，`char s[] = "hello";` 中的 “hello” 是数组类型的左值（lvalue），用于初始化 s 数组；`sizeof( "hello" )` 以及 `&"hello"` 中的 "hello" 也都是左值。在这些情况下，"hello" 处于左值语义上下文环境中，所以不会产生下面将要提到的数组转换为指针的现象。另外，有些运算不但要求其操作数是左值，还要求可变。例如，对对象进行赋值、自加、自减等运算。因为数组是不可被更改的左值，所以不能对数组进行这些操作，也就是说不存在数组类型的赋值、自加、自减等运算。

5)  字符串字面量可以转换为指向其首第一个字符的指针
处于右值语义环境中的字符串字面量将被默认转换为指向第一个字符的指针。例如，`char* p = "hello"; `中的 “hello” 在转换为字符指针后用于初始化指针变量 p；表达式 "hello"[0]（相当于 `*("hello" + 0) `或者 `*"hello"`）中的 “hello” 也是同样转换为指针后参与下标运算，等等。这种性质也是数组类型的特点。在右值语义环境下，一般类型的对象表示的值是由其存储内容决定的；而数组类型的对象与此不同，它代表的值不是来源于其内容，而是来源于数组对象首元素所在的地址。这是数组最为特殊的地方，也是人们容易产生误解的地方。

6)  取地址运算
字符串字面量是一个可取址的对象。例如：`&"hello"` 是合法的表达式。

7)  地址常量
静态对象的地址在编译期间即可被确定，所以其地址（如 `&"hello"`）是常量；而字符串字面量又可以从数组类型自动转换为指针（如 "hello" 转换为指针后等同于 `&"hello"[0]`），所以字符串字面量可以直接作为地址常量表达式来使用。

8)  修改字符串字面量的行为是无定义的
下面的操作都试图修改字符串字面量中的第一个字符从而改变字符串字面量，所以其结果是无定义（Undefined）的,使用了无定义行为的程序是错误的；避免在程序中出现无定义行为是程序员的责任。：

``` cpp
”hello”[0] = ‘A’; /* Undefined */
char* p = “hello”; *p = ‘A’; /* Undefined */
```

9)  C和C＋＋对于字符串字面量的区别
下面代码是合法的 C 代码，但是作为 C++ 代码是非法的。非法的原因在于："hello" 转换为 `char const * `指针类型，而不能转换为 `char *`，因为 + 运算符对其操作数的类型没有转换为 `char*` 这样直接的要求（因为无论是 `char const *` 还是 `char*` 都能进行指针加法运算），所以指针加法表达式的结果仍然是 `char const *` 类型。这样，上面指针的初始化或赋值操作就违反了在类型上的约束条件，需要给出诊断信息。

``` cpp
char* p = "hello" + 1;
char* q; q = "hello" + 1;
void foo( char* s ); foo( "hello" + 1 );
```
## GCC/G++/C/C++的区别

``` cpp
gcc 是c的编译器，g++是c++的编译器。cc一般是一个符号连接，指向gcc。 
CC一般是makefile里面的一个名字，具体是什么根据实际情况决定。 
gcc和g++都是GNU(组织)的一个编译器。 

> 误区一:gcc只能编译c代码,g++只能编译c++代码

两者都可以，但是请注意： 
1,后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。C++的语法规则更加严谨一些。 
2,编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。 

> 误区二:gcc不会定义`__cplusplus`宏，而g++会

实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释，如上所述，如果后缀为.c，并且采用gcc编译器，则该宏就是未定义的，否则，就是已定义。 

> 误区三:编译只能用gcc，链接只能用g++

严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。 

> 请问CC cc gcc g++本质区别在什么地方？

传统上, UNIX OS 会配带 C compiler by default. 一般用符号名 cc. 而C++ compiler 需要另外买. 
常见的有: 
Linux: gcc/g++ 
Solaris: cc/CC 
HP-UX: aCC 
AIX: xlc/xlC 
SCO: ?/? 
几乎所有的情况, C/C++ compiler 都只是front end driver. 后面的编译器是一样的. 比如gcc, g++ 提供不同的选项给编译器以及link editor. 这些包括用户选项, 缺省选项, 对应的缺省系统库. 每个compiler有一个configuratoin file来指定这些缺省选项. 使用 verbose mode (-v) 可以看到这些内容. 
C++ 程序因为语法(namespace, class, overload...), 需要mangle 所有的symbol name. 与C程序link的时候需要用extern "C". 
C++的编译器肯定可以编译C的的代码，注意除了C++对C的语法扩充之外，编译和链接C和C++的标准库通常也不一样呢。
```


