---
title: C++疑难笔记
tags: C++,难点
grammar_cjkRuby: true
---


## C&C++的编译过程
编译过程主要分为4个过程  
1) **编译预处理**  预编译程序完成的工作，可以说成是对源程序的“替换”工作。经过这个过程，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。

> 宏定义命令；例如#define

> 条件编译指令；例如#ifdef
 
> 头文件包含指令；例如#include

> 特殊符号；例如__LINE__

> 预处理模块；例如#pragma

2) **编译、优化阶段**  通过词法分析、语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码或汇编代码。
在C++中，以下函数如果你没有定义但是被需要时，编译器会产生他们：默认构造函数、拷贝构造函数、析构函数、赋值运算符和一对取址运算符。

3) **汇编过程**   把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。

4) **链接程序**  将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。
CPP使用链接器以确保用到的函数都只被定义一次，以及确保static objects只被定义一次，会将我们做了声明但却未曾定义的函数检测出来。
链接有静态链接和动态链接。
C/C++编译过程 中，对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一 些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。

> **静态链接**：在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。

> **动态链接**：在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。备注：头文件里我们通常只放置声明而不是定义，因为头文件有可能被释放到多个源文件中，每个源文件都会单独编译，这样链接时就会发现全局空间中有多个定义了。

## 头文件`#include<bits/stdc++.h>`

Hi! See this useful C++ include directive.
This let you use any C/C++ standard library without adding extra "includes". No more compilation errors because missing libraries :)
And you can make a shorter version of your template. For example, my template.

``` cpp
  #include <bits/stdc++.h>
  #define _ ios_base::sync_with_stdio(0);cin.tie(0);

  using namespace std;

  int main() { 
    return 0;
  }
//I tested it with the GNU/C++ compiler.
```
不过在国内oj中，poj，hdu 不支持这个函数.


## 字符串字面量&字符字面量

``` cpp
char *ch=hello;
sizeof(ch);//指针，值为4
ch[1]='t';//error，不可更改

char ch[]="hello";
sizeof(ch);//数组，值为6
ch[1]='t';//OK，可以更改
```
当ch[]作为参数传递给函数时，ch退化为指针，此时sizeof(ch)＝4；

1)  字符串字面量是对象
C/C++ 中的对象（Object）指的是一块存储区。字符串字面量是不需要创建过程就可使用的对象，所以它既没有变量那样的声明或者定义（字符串字面量是无名对象），也不需要象动态分配的对象那样进行动态分配。由于这个原因，用来限定变量的类型限定符（如 const、volatile）以及存储类别指示符（如 extern、static、auto、register）不能用在修饰字符串字面量上。

2) 数组类型
字符串字面量是数组类型的对象，因而具有数组的一切特点。关于这一点在下面还会进一步说明。

3)  静态存储区
C/C++ 中对象的生存期按照其存储性质可分为三类：静态存储期（static storage duration）、自动存储期（automatic storage duration）以及动态存储期（dynamic storage duration）。相应地，对象可根据存储期性质分为静态对象、自动对象和动态对象三种。字符串字面量是静态对象，所以在程序运行期间会一直存在。

4) 字符串字面量是左值，而且是不可被更改的左值。
例如，`char s[] = "hello";` 中的 “hello” 是数组类型的左值（lvalue），用于初始化 s 数组；`sizeof( "hello" )` 以及 `&"hello"` 中的 "hello" 也都是左值。在这些情况下，"hello" 处于左值语义上下文环境中，所以不会产生下面将要提到的数组转换为指针的现象。另外，有些运算不但要求其操作数是左值，还要求可变。例如，对对象进行赋值、自加、自减等运算。因为数组是不可被更改的左值，所以不能对数组进行这些操作，也就是说不存在数组类型的赋值、自加、自减等运算。

5)  字符串字面量可以转换为指向其首第一个字符的指针
处于右值语义环境中的字符串字面量将被默认转换为指向第一个字符的指针。例如，`char* p = "hello"; `中的 “hello” 在转换为字符指针后用于初始化指针变量 p；表达式 "hello"[0]（相当于 `*("hello" + 0) `或者 `*"hello"`）中的 “hello” 也是同样转换为指针后参与下标运算，等等。这种性质也是数组类型的特点。在右值语义环境下，一般类型的对象表示的值是由其存储内容决定的；而数组类型的对象与此不同，它代表的值不是来源于其内容，而是来源于数组对象首元素所在的地址。这是数组最为特殊的地方，也是人们容易产生误解的地方。

6)  取地址运算
字符串字面量是一个可取址的对象。例如：`&"hello"` 是合法的表达式。

7)  地址常量
静态对象的地址在编译期间即可被确定，所以其地址（如 `&"hello"`）是常量；而字符串字面量又可以从数组类型自动转换为指针（如 "hello" 转换为指针后等同于 `&"hello"[0]`），所以字符串字面量可以直接作为地址常量表达式来使用。

8)  修改字符串字面量的行为是无定义的
下面的操作都试图修改字符串字面量中的第一个字符从而改变字符串字面量，所以其结果是无定义（Undefined）的,使用了无定义行为的程序是错误的；避免在程序中出现无定义行为是程序员的责任。：

``` cpp
”hello”[0] = ‘A’; /* Undefined */
char* p = “hello”; *p = ‘A’; /* Undefined */
```

9)  C和C＋＋对于字符串字面量的区别
下面代码是合法的 C 代码，但是作为 C++ 代码是非法的。非法的原因在于："hello" 转换为 `char const * `指针类型，而不能转换为 `char *`，因为 + 运算符对其操作数的类型没有转换为 `char*` 这样直接的要求（因为无论是 `char const *` 还是 `char*` 都能进行指针加法运算），所以指针加法表达式的结果仍然是 `char const *` 类型。这样，上面指针的初始化或赋值操作就违反了在类型上的约束条件，需要给出诊断信息。

``` cpp
char* p = "hello" + 1;
char* q; q = "hello" + 1;
void foo( char* s ); foo( "hello" + 1 );
```
## size_t是什么
1) size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。
	例如：bitset的size操作返回bitset对象中二进制位中的个数，返回值类型是size_t。
	例如：在用下标访问元素时，vector使用vector::size_type作为下标类型，而数组下标的正确类型则是size_t。vector使用的下标实际也是size_t，源码是typedef size_t size_type。

2) 一个基本的无符号整数的C / C + +类型， 它是sizeof操作符返回的结果类型， 该类型的大小是选择。因此，它可以存储在理论上是可能的任何类型的数组的最大大小。 换句话说，一个指针可以被安全地放进为size_t类型（一个例外是类的函数指针，但是这是一个特殊的情况下）。 size_t类型通常用于循环、数组索引、大小的存储和地址运算。 虽然size_t可以存储一个指针，它的目的是更好地使用另一个unsinged整数类型uintptr_t形式。 在某些情况下，使用size_t类型是更为有效，比习惯性使用无符号类型的程序会更安全。
	size_t是在基于无符号整数memsize类型的C / C + +的标准库中定义的。 C语言中，此类型位于头文件stddef.h中，而在C++中，则位于cstddef中。
    
 3) size_t在C语言中就有了。
	它是一种“整型”类型，里面保存的是一个整数，就像int, long那样。这种整数用来记录一个大小(size)。size_t的全称应该是size type，就是说“一种用来记录大小的数据类型”。通常我们用sizeof(XXX)操作，这个操作所得到的结果就是size_t类型。因为size_t类型的数据其实是保存了一个整数，所以它也可以做加减乘除，也可以转化为int并赋值给int类型的变量。类似的还有wchar_t, ptrdiff_t。wchar_t就是wide char type，“一种用来记录一个宽字符的数据类型”。ptrdiff_t就是pointer difference type，“一种用来记录两个指针之间的距离的数据类型”。通常，size_t和ptrdiff_t都是用typedef来实现的。你可能在某个头文件里面找到类似的语句：`typedef unsigned int size_t;`而wchar_t则稍有不同。在一些旧的编译器中，`wchar_t`也可能是用typedef来实现，但是新的标准中`wchar_t`已经是`C/C++`语言的关键字，`wchar_t`类型的地位已经和`char`, `int`的地位等同了。在标准C/C++的语法中，只有int float char bool等基本的数据类型，至于`size_t`或`size_type`都是以后的编程人员为了方便记忆所定义的一些便于理解的由基本数据类型的变体类型。例如：`typedef int size_t`定义了`size_t`为整型。
    
 4) 示例代码：
``` stylus
int i;//定义一个int类型的变量i
size_t size=sizeof(i);//用sizeof操作得到变量i的类型的大小
//这是一个size_t类型的值
//可以用来对一个size_t类型的变量做初始化
i=(int)size;//size_t类型的值可以转化为int类型的值
char c='a';//c保存了字符a，占一个字节
wchar_twc=L'a';//wc保存了宽字符a，占两个字节
//注意'a'表示字符a，L'a'表示宽字符a
intarr[]={1,2,3,4,5};//定义一个数组
int*p1=&arr[0];//取得数组中元素的地址，赋值给指针
int*p2=&arr[3];
ptrdiff_t diff=p2-p1;//指针的减法可以计算两个指针之间相隔的元素个数
//所得结果是一个ptrdiff_t类型
i=(int)diff;//ptrdiff_t类型的值可以转化为int类型的值
```




