---
title: 数据库总结 
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---


## SQL基础知识
### 数据库范式

1、第一范式（1NF）：强调的是列的**原子性**，即列不能够再分成其他几列。
如电话列可进行拆分---家庭电话、公司电话

2、第二范式（2NF）：首先是 1NF，另外包含两部分内容，一是表必须有主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。也就是说在一个数据库表中，**一个表中只能保存一种数据**，不可以把多种数据保存在同一张数据库表中。

比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。

3、第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在**传递依赖**。
比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）
这样一个表结构，就存在上述关系。 学号--> 所在院校 --> (院校地址，院校电话)
这样的表结构，我们应该拆开来，如下。
（学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）

满足这些规范的数据库是简洁的、结构明晰的；同时，不会发生插入（insert）、删除（delete）和更新（update）操作异常。

### 数据类型的选择

1、数字类型

Float和double选择（尽量选择float）

区分开TINYINT / INT / BIGINT，能确定不会使用负数的字段，建议添加 unsigned定义

> 能够用数字类型的字段尽量选择数字类型而不用字符串类型的

2、字符类型

char,varchar,TEXT的选择：非万不得已不要使用 TEXT 数据类型，定长字段，建议使用 CHAR 类型（填空格），不定长字段尽量使用 VARCHAR（自动适应长度，超过阶段），且仅仅设定适当的最大长度

3、时间类型

按选择优先级排序DATE（精确到天）、TIMESTAMP、DATETIME（精确到时间）

4、ENUM

对于状态字段，可以尝试使用 ENUM 来存放

> 避免使用NULL字段，很难查询优化且占用额外索引空间

### 数据库事物
#### 数据库事物的四大特征
1、**原子性**

事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。

2、**一致性**

事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。

3、**隔离性**（关于事务的隔离性数据库提供了多种隔离级别）

一个事务的执行不能干扰其它事务。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。

4、**持久性**

事务完成之后，它对于数据库中的数据改变是永久性的。该修改即使出现系统故障也将一直保持。
#### 数据库事物的异常

1、脏读

脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

2、不可重复读和幻读

幻读和不可重复读都是读取了另一条已经提交的事务,不可重复读重点在于update和delete，而幻读的重点在于insert。

在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复 读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。**需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥**，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

#### 数据库锁模式

1、共享锁:（读取）操作创建的锁。其他用户可以并发读取数据，但任何事物都不能获取数据上的排它锁，直到已释放所有共享锁。

2、排他锁（X锁）：对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。

3、更新锁:
更新(U)锁可以防止通常形式的死锁。如果两个事务获得了资源上的共享模式锁，然后试图同时更新数据，则两个事务需都要转换共享锁为排它(X)锁，并且每个事务都等待另一个事务释放共享模式锁，因此发生死锁。
若要避免这种潜 在的死锁问题，请使用更新(U)锁。一次只有一个事务可以获得资源的更新(U)锁。如果事务修改资源，则更新(U)锁转换为排它(X)锁。否则，锁转换为共享锁。

#### 锁的粒度

锁的粒度主要有以下几种类型：

1、行锁： 粒度最小，并发性最高

2、页锁：一次锁定一页。25个行锁可升级为一个页锁。

3、表锁：粒度大，并发性低

4、数据库锁：控制整个数据库操作

#### MySQL的四种隔离级别：

1、Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。

2、Repeatable read (可重复读)：可避免脏读、不可重复读的发生。

3、Read committed (读已提交)：可避免脏读的发生。

4、Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。

### SQL基本操作

见如下的博客：
http://blog.csdn.net/basycia/article/details/52134279

### SQL函数

``` stylus
Avg()  Count()  Max()  Min()  Sum()

Group By():
```
**GROUP BY** 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。

``` sql
SELECT column_name, aggregate_function(column_name)
FROM table_name WHERE column_name operator value
GROUP BY column_name;
```


**HAVING** 子句可以让我们筛选分组后的各组数据。

``` sql
SELECT column_name, aggregate_function(column_name)
FROM table_name WHERE column_name operator value
GROUP BY column_name 

HAVING aggregate_function(column_name) operator value;
```


### SQL优化

#### 优化思路方向

- 索引问题

在做性能跟踪分析过程中，经常发现有不少后台程序的性能问题是因为缺少合适索引造成的，有些表甚至一个索引都没有。这种情况往往都是因为在设计表时，没去定义索引，而开发初期，由于表记录很少，索引创建与否，可能对性能没啥影响，开发人员因此也未多加重视。然一旦程序发布到生产环境，随着时间的推移，表记录越来越多

这时缺少索引，对性能的影响便会越来越大了。

这个问题需要数据库设计人员和开发人员共同关注

法则：不要在建立的索引的数据列上进行下列操作:

> 避免对索引字段进行计算操作
> 避免在索引字段上使用not，<>，!=
> 避免在索引列上使用IS NULL和IS NOT NULL
> 避免在索引列上出现数据类型转换
> 避免在索引字段上使用函数
> 避免建立索引的列中使用空值。

- 复杂操作

部分UPDATE、SELECT 语句 写得很复杂(经常嵌套多级子查询)——可以考虑适当拆成几步，先生成一些临时数据表，再进行关联操作。

- 在可以使用UNION ALL的语句里，使用了UNION

UNION 因为会将各查询子集的记录做比较，故比起UNION ALL ，通常速度都会慢上许多。一般来说，如果使用UNION ALL能满足要求的话，务必使用UNION ALL。还有一种情况大家可能会忽略掉，就是虽然要求几个子集的并集需要过滤掉重复记录，但由于脚本的特殊性，不可能存在重复记录，这时便应该使用UNION ALL，如xx模块的某个查询程序就曾经存在这种情况，见，由于语句的特殊性，在这个脚本中几个子集的记录绝对不可能重复，故可以改用UNION ALL)

- where语句

1、避免在WHERE子句中使用in，not in，or 或者having。

可以使用 exist 和not exist代替 in和not in。
可以使用表链接代替 exist。Having可以用where代替

2、不要以字符格式声明数字，要以数字格式声明字符值。(日期同样)否则会使索引无效，产生全表扫描。

- 排序

避免使用耗费资源的操作，带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎 执行，耗费资源的排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序。

- 临时表

慎重使用**临时表**可以极大的提高系统性能

#### 优化总结

1) 只返回需要的数据

	a) 不要写SELECT *的语句

	b) 合理写WHERE子句，不要写没有WHERE的SQL语句。

2) 尽量少做重复的工作，可以合并一些sql语句

3) 适当建立索引（不是越多越好）但以下几点会进行全表扫描

	a) 左模糊查询’%...’

	b) 使用了不等操作符！=

	c) Or使用不当，or两边都必须有索引才行

	d) In 、not in

	e) Where子句对字段进行表达式操作

	f) 对于创建的复合索引（从最左边开始组合），查询条件用到的列必须从左边开始不能间隔。否则无效，复合索引的结构与电话簿类似

	g) 全文索引：当于对文件建立了一个以词库为目录的索引（文件大全文索引比模糊匹配效果好）能在char、varchar、text类型的列上面创建全文索引MySQL 5.6  Innodb引擎也能进行全文索引搜索语法：MATCH (列名1, 列名2,…) AGAINST (搜索字符串 [搜索修饰符])如果列类型是字符串，但在查询时把一个数值型常量赋值给了一个字符型的列名name，那么虽然在name列上有索引，但是也没有用到。

4) 使用join代替子查询

5) 使用union代替手动创建临时表
