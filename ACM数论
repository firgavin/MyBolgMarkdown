---
title: ACM数论
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---


欢迎使用 **{小书匠}(xiaoshujiang)编辑器**，您可以通过==设置==里的修改模板来改变新建文章的内容。

### 素数的判定
一个数 n 如果是合数，那么它的所有的因子不超过`sqrt(n)`，复杂度是`o(n*sqrt(n))`：

``` cpp
bool prime(int x){//判断x是不是质数，是返回true，不是返回false 
    if(x <= 1) return false; 
    for(int i = 2; i <= sqrt(x + 0.5); i ++){//0.5是防止根号的精度误差 
        if(x % i == 0) return false;
    }
    return true;
}
```
或者是这样写也行：

``` cpp
bool prime(int x){//判断x是不是质数，是返回true，不是返回false 
    if(x <= 1) return false; 
    for(int i = 2; i * i <= x; i ++){//用乘法避免根号的精度误差 
        if(x % i == 0) return false;
    }
    return true;
}
//根据题目不同，如果i*i会爆int，记得开longlong
```
引入素数表来进行维护：

``` cpp
bool IsPrime(unsigned n)
{
    if ( n < 2 )
    { // 小于2的数即不是合数也不是素数
        throw 0;
    }
    static unsigned aPrimeList[] = { // 素数表
        1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,
        43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 113, 
        193, 241, 257, 337, 353, 401, 433, 449, 577, 593, 641, 
        673, 769, 881, 929, 977, 1009, 1153, 1201, 1217, 1249, 
        1297,1361, 1409, 1489, 1553, 1601, 1697, 1777, 1873, 
        1889, 2017, 2081, 2113, 2129, 2161, 2273, 2417, 2593, 
        2609, 2657, 2689, 2753, 2801, 2833, 2897, 3041, 3089, 
        3121, 3137, 3169, 3217, 3313, 3329, 3361, 3457, 3617, 
        3697, 3761, 3793, 3889, 4001, 4049, 4129, 4177, 4241, 
        4273, 4289, 4337, 4481, 4513, 4561, 4657, 4673, 4721, 
        4801, 4817, 4993, 5009, 5153, 5233, 5281, 5297, 5393, 
        5441, 5521, 5569, 5857, 5953, 6113, 6257, 6337, 6353, 
        6449, 6481, 6529, 6577, 6673, 6689, 6737, 6833, 6961, 
        6977, 7057, 7121, 7297, 7393, 7457, 7489, 7537, 7649, 
        7681, 7793, 7841, 7873, 7937, 8017, 8081, 8161, 8209, 
        8273, 8353, 8369, 8513, 8609, 8641, 8689, 8737, 8753, 
        8849, 8929, 9041, 9137, 9281, 9377, 9473, 9521, 9601, 
        9649, 9697, 9857 
    };
    
    const int nListNum = sizeof(aPrimeList)/sizeof(unsigned);//计算素数表里元素的个数
    for (unsigned i=2;i<nListNum;++i )
    { 
        if(n/2+1<aPrimeList[i])
        {
            return true;
        }
        if(0==n%aPrimeList[i])
        {
            return false;
        }
    }
   
    for (unsigned i=aPrimeList[nListNum-1];i<n/2+1;i++ )
    { 
        if (0==n%i)
        { // 除尽了，合数 
            return false;
        }
    }
    return true; 
} 
```
二次探测定理：如果p是素数，且`0<x<p`，则方程`x^2=1(mod p)`的解为1或p-1。
最后一种情况，面对大数时采用Miller-Rabbin素数测试法：
Miller-Rabbin素数测试是一个不确定的算法，只能从概率意义上判定一个数可能是素数，但并不能确保。算法流程如下:
    1.选择T个随机数A，并且有A<N成立。
    2.找到R和M，使得`N=2*R*M+1`成立。
    快速得到R和M的方式：N用二进制数B来表示，令C=B-1。因为N为奇数（素数都是奇数），所以C的最低位为0，从C的最低位的0开始向高位统计，一直到遇到第一个1。这时0的个数即为R，M为B右移R位的值。
    3.如果A^M%N=1，则通过A对于N的测试，然后进行下一个A的测试
    4.如果A^M%N!=1，那么令i由0迭代至R，进行下面的测试
    5.如果`A^((2^i)*M)%N=N-1`则通过A对于N的测试，否则进行下一个i的测试 
    6.如果i=r，且尚未通过测试，则此A对于N的测试失败，说明N为合数。
    7.进行下一个A对N的测试，直到测试完指定个数的A
    通过验证得知，当T为素数，并且A是平均分布的随机数，那么测试有效率为1 / ( 4 ^ T )。如果T > 8那么测试失误的机率就会小于10^(-5)，这对于一般的应用是足够了。如果需要求的素数极大，或着要求更高的保障度，可以适当调高T的值。

``` cpp
int Miller_Rabbin(long long n)    
{    
    long long i,s,a;    
    s=10;    //s的值可以根据需要变大    
 // randomize();    
    for(i=0;i <s;i++)    
    {    
        a=long long(rand()%(n-1)+2); //自动生成受限    
        if(modular_exp(a,n-1,n)>1)    
            return 0;    
    }    
    return 1;    
}    
long long modular_exp(long long a,long long b,long long c)//求a^b%c该函数受限    
{    
    if(a==0)    
        return 0;    
    if(b==0)    
        return 1;    
    if(b==1)    
        return a%c;    
    return (a*modular_exp(a,b-1,c))%c;    
} 
```
完整版代码：

``` cpp

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
#include <iostream>
#include <math.h>

using namespace std;
const int Times = 10;
typedef long long LL;

LL multi(LL a, LL b, LL m)
{
    LL ans = 0;
    a %= m;
    while(b)
    {
        if(b & 1)
        {
            ans = (ans + a) % m;
            b--;
        }
        b >>= 1;
        a = (a + a) % m;
    }
    return ans;
}

LL quick_mod(LL a, LL b, LL m)
{
    LL ans = 1;
    a %= m;
    while(b)
    {
        if(b & 1)
        {
            ans = multi(ans, a, m);
            b--;
        }
        b >>= 1;
        a = multi(a, a, m);
    }
    return ans;
}

bool Miller_Rabin(LL n)
{
    if(n == 2) return true;
    if(n < 2 || !(n & 1)) return false;
    LL m = n - 1;
    int k = 0;
    while((m & 1) == 0)
    {
        k++;
        m >>= 1;
    }
    for(int i=0; i<Times; i++)
    {
        LL a = rand() % (n - 1) + 1;
        LL x = quick_mod(a, m, n);
        LL y = 0;
        for(int j=0; j<k; j++)
        {
            y = multi(x, x, n);
            if(y == 1 && x != 1 && x != n - 1) return false;
            x = y;
        }
        if(y != 1) return false;
    }
    return true;
}

int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        LL n;
        scanf("%I64d",&n);
        if(Miller_Rabin(n)) puts("Yes");
        else puts("No");
    }
    return 0;
}

```
质数检测Java大数版：

``` java
import java.io.*;
import java.util.*;
import java.math.BigInteger;
 
public class Main{
	    public static final int Times = 10;
	    
	    public static BigInteger quick_mod(BigInteger a,BigInteger b,BigInteger m){
	    		BigInteger ans = BigInteger.ONE;
	    		a = a.mod(m);
	    		while(!(b.equals(BigInteger.ZERO))){
	    				if((b.mod(BigInteger.valueOf(2))).equals(BigInteger.ONE)){
	    						ans = (ans.multiply(a)).mod(m);
	    						b = b.subtract(BigInteger.ONE);
	    				}
	    				b = b.divide(BigInteger.valueOf(2));
	    				a = (a.multiply(a)).mod(m);
	    		}
	    		return ans;
	    }
	    
	 	public static boolean Miller_Rabin(BigInteger n){
	 			if(n.equals(BigInteger.valueOf(2))) return true;
	 			if(n.equals(BigInteger.ONE)) return false;
	 			if((n.mod(BigInteger.valueOf(2))).equals(BigInteger.ZERO)) return false;
	 			BigInteger m = n.subtract(BigInteger.ONE);
	 			BigInteger y = BigInteger.ZERO;
	 			int k = 0;
	 			while((m.mod(BigInteger.valueOf(2))).equals(BigInteger.ZERO)){
	 					k++;
	 					m = m.divide(BigInteger.valueOf(2));
	 			}
	 			Random d = new Random();
	 			for(int i=0;i<Times;i++){
	 				    int t = 0;
	 				    if(n.compareTo(BigInteger.valueOf(10000)) == 1){
	 				    		t = 10000;
	 				    }else{
	 				    	    t = n.intValue() - 1;
	 				    }
	 					int a = d.nextInt(t) + 1;
	 					BigInteger x = quick_mod(BigInteger.valueOf(a),m,n);
	 					for(int j=0;j<k;j++){
	 							y = (x.multiply(x)).mod(n);
	 							if(y.equals(BigInteger.ONE) && !(x.equals(BigInteger.ONE)) && !(x.equals(n.subtract(BigInteger.ONE)))) return false;
	 							x = y;
	 					}
	 					if(!(y.equals(BigInteger.ONE))) return false;
	 			}
	 			return true;
	 	}
	 	
		public static void main(String[] args){
				Scanner cin = new Scanner(System.in);
				while(cin.hasNextBigInteger()){
						BigInteger n = cin.nextBigInteger();
						if(Miller_Rabin(n)) System.out.println("Yes");
						else System.out.println("No");
				}
		}
}
 
```






### 素数的筛选（构造素数表）
不采用筛素：假设我们已经我素数序列: p1, p2, .. pn
现在要判断pn+1是否是素数, 则需要(1, sqrt(pn+1)]范围内的所有素数序列,
而这个素数序列显然已经作为p1, p2, .. pn的一个子集被包含了

``` cpp
void makePrimes(int primes[], int num)
{
	int i, j, cnt;

	primes[0] = 2;
	primes[1] = 3;

	for(i = 5, cnt = 2; cnt < num; i += 2)
	{
		int flag = true;
		for(j = 1; primes[j]*primes[j] <= i; ++j)
		{
			if(i%primes[j] == 0)
				{
					flag = false; break;
				}
		}
		if(flag) primes[cnt++] = i;
	}
}
```


可以使用筛素法，复杂度`O(nloglogn)`：

``` cpp
bool prime[N];
void init(){
    for(int i = 2; i < N; i ++) prime[i] = true;
    for(int i = 2; i*i < N; i ++){//判断改成i*i<N 
        if(prime[i]){
            for(int j = i*i; j < N; j += i){//从i*i开始就可以了 
                prime[j] = false;  
            }
        }
    }
}
```
或者采用线性筛素法`O(n)`：

``` cpp
#include<cstdio>
const int N = 100000 + 5;
bool prime[N];//prime[i]表示i是不是质数 
int p[N], tot;//p[N]用来存质数 
void init(){
    for(int i = 2; i < N; i ++) prime[i] = true;//初始化为质数 
    for(int i = 2; i < N; i++){
        if(prime[i]) p[tot ++] = i;//把质数存起来 
        for(int j = 0; j < tot && i * p[j] < N; j++){
            prime[i * p[j]] = false;
            if(i % p[j] == 0) break;//保证每个合数被它最小的质因数筛去 
        }
    }    
}
int main(){
    init();
}
```



### 素数的性质

### 幂乘快速计算（二分思想）
逆向思维，不断地二分，累积底数的平方即可：

``` cpp
typedef long long LL;

LL pow_mod(LL a, LL b, LL p){//a的b次方求余p 
    LL ret = 1;
    while(b){
        if(b & 1) ret = (ret * a) % p;
        a = (a * a) % p;
        b >>= 1;
    }
    return ret;
}
```
衍生出ll的快速乘：

``` cpp
LL mul(LL a, LL b, LL p){//快速乘，计算a*b%p 
    LL ret = 0;
    while(b){
        if(b & 1) ret = (ret + a) % p;
        a = (a + a) % p;
        b >>= 1;
    }
    return ret;
}
```
关于计算结果过除以MOD取余的问题：
1、计算加法每相加一次执行一次取余；
2、计算减法给被减数加上MOD之后先减法后取余；
3、计算乘法每相乘一次取余一次。

### GCD&LCM的相关
计算gcd循环写法和递归写法：

``` cpp
LL gcd(LL a, LL b){
    if(b == 0) return a;
    else return gcd(b, a%b);
}

LL gcd(LL a, LL b){
    return b ? gcd(b, a%b) : a;
}

LL gcd(LL a, LL b){
    LL t;
    while(b){
        t = b;
        b = a % b;
        a = t;
    }
    return a;
}
```
相关的公式：

``` stylus
a*b = gcd(a,b) * lcm(a,b)
gcd(ka, kb) = k * gcd(a, b)
lcm(ka, kb) = k * lcm(a, b)
lcm(S/a, S/b) = S/gcd(a, b)
```

### 扩展欧几里德算法
那么已知 a，b 求 一组解 x，y 满足 ax+by = gcd(a, b) 这个公式:

![enter description here][1]

代码模板：
 
``` cpp
#include<cstdio>
typedef long long LL;
void ex_Eulid(LL a, LL b, LL &x, LL &y, LL &d){
    if (!b) {d = a, x = 1, y = 0;}
    else{
        extend_Eulid(b, a % b, y, x, d);
        y -= x * (a / b);
    }
}
int main(){
    LL a, b, d, x, y;
    while(~scanf("%lld%lld", &a, &b)){
        ex_Eulid(a, b, x, y, d);
        printf("%lld*a + %lld*b = %lld\n", x, y, d);
    }
}
```

### 威尔逊定理
当且仅当p为素数时：( p -1 )! ≡ -1 ( mod p )
或者这么写( p -1 )! ≡ p-1 ( mod p )
若p为质数，则p能被(p-1)!+1整除
在初等数论中，这是威尔逊给出了判定一个自然数是否为素数的充分必要条件。

### 欧拉定理
欧拉定理，也称费马-欧拉定理
若n,a为正整数，且n,a互质，即gcd(a,n) = 1，则a^φ(n) ≡ 1 (mod n)
 
φ(n) 是欧拉函数，欧拉函数是求小于等于n的数中与n互质的数的数目  
欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目或者说欧拉函数是求 1到n-1 中 与n互质的数的数目。
 
如果n是质数那么1到n-1所有数都是与n互质的，所以φ(n) = n-1

### 中国剩余定理
![CRT问题描述][2]

CRT问题代码描述如下：

``` cpp
void extend_Euclid(LL a, LL b, LL &x, LL &y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return;
    }
    extend_Euclid(b, a % b, x, y);
    LL tmp = x;
    x = y;
    y = tmp - (a / b) * y;
}

int CRT(int a[],int m[],int n)
{
    int M = 1;
    int ans = 0;
    for(int i=1; i<=n; i++)
        M *= m[i];
    for(int i=1; i<=n; i++)
    {
        int x, y;
        int Mi = M / m[i];
        extend_Euclid(Mi, m[i], x, y);
        ans = (ans + Mi * x * a[i]) % M;
    }
    if(ans < 0) ans += M;
    return ans;
}
```


### 费马小定理
假如p是质数：
若p不能整除a，则 a^(p-1) ≡1（mod p）；
若p能整除a，则a^(p-1) ≡0（mod p）。
或者说，若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。

### 高斯消元
高斯消元是用来求线性方程组的解，行列式求值，或者矩阵求逆等等。主要有两个步骤：化行阶梯形矩阵和回带。
高斯消元的时间复杂度为O(n^3)，以下代码中n代表方程个数，m代表未知数个数，数组f用来判断哪些未知数是
变元，数组x用来存求得的解。

``` cpp
#include <iostream>
#include <string.h>
#include <algorithm>
#include <stdio.h>
#include <math.h>

using namespace std;
const int N = 105;

int gcd(int a,int b)
{
    return b ? gcd(b,a%b):a;
}

int lcm(int a,int b)
{
    return a / gcd(a,b) * b;
}

/**n个方程，m个未知数，r代表当前处理的行，c代表当前处理的列*/
void Gauss(int a[][N],int n,int m,int &r,int &c)
{
    r = c = 0;
    for(; r<n && c<m; r++,c++)
    {
        int maxi = r;
        for(int i=r+1; i<n; i++)
            if(abs(a[i][c]) > abs(a[maxi][c]))
                maxi = i;
        if(maxi != r)
        {
            for(int i=r; i<m+1; i++)
                swap(a[r][i],a[maxi][i]);
        }
        if(a[r][c] == 0)
        {
            r--;
            continue;
        }
        for(int i=r+1; i<n; i++)
        {
            if(a[i][c] != 0)
            {
                int x = abs(a[i][c]);
                int y = abs(a[r][c]);
                int LCM = lcm(x,y);
                int tx = LCM / x;
                int ty = LCM / y;
                if(a[i][c] * a[r][c] < 0)
                    ty = -ty;
                for(int j=c; j<m+1; j++)
                    a[i][j] = a[i][j] * tx - a[r][j] * ty;
            }
        }
    }
}

int Rewind(int a[][N],int x[],bool f[],int n,int m,int r,int c)
{
    for(int i=r; i<n; i++)
        if(a[i][c] != 0)
            return -1;
    if(r < m)
    {
        memset(f,1,sizeof(f));
        for(int i=r-1; i>=0; i--)
        {
            int id = 0;
            int cnt = 0;
            for(int j=0; j<m; j++)
            {
                if(a[i][j] != 0 && f[j])
                {
                    cnt++;
                    id = j;
                }
            }
            if(cnt > 1) continue;
            int t = a[i][m];
            for(int j=0; j<m; j++)
            {
                if(a[i][j] != 0 && j != id)
                    t -= a[i][j] * x[j];
            }
            x[id] = t / a[i][id];
            f[id] = 0;
        }
        return m - r;
    }
    for(int i=r-1; i>=0; i--)
    {
        int t = a[i][c];
        for(int j=i+1; j<c; j++)
        {
            if(a[i][j] != 0)
                t -= a[i][j] * x[j];
        }
        if(t % a[i][i] != 0) return -2;
        x[i] = t / a[i][i];
    }
    return 0;
}

void Print(int a[][N],int n,int m)
{
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<m+1; j++)
            cout<<a[i][j]<<" ";
        cout<<endl;
    }
}

int a[N][N];
int x[N];
bool f[N];

int main()
{
    int n,m;
    while(cin>>n>>m)
    {
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<m+1; j++)
                cin>>a[i][j];
        }
        int r,c;
        Gauss(a,n,m,r,c);
        Rewind(a,x,f,n,m,r,c);
        Print(a,n,m);
        puts("");
    }
    return 0;
}
```

### 求n!，C(n,m)，A(n,m)最后的非零位

> 先说说怎样求n!最后的非零位吧！
> 比如找10！最后的非零位，由于质因数2和5的组合之后末尾会产生0，所以我们先把2，5的质因子全部去掉，由于2的数目要比5多，所以我们要在最后考虑
> 多余的2对末尾的影响。 比如：1*2*3*4*5*6*7*8*9*10去掉2，5的因子后就是：
> 1*1*3*1*1*3*7*1*9*1，由于去掉了2，5，那么剩下的数字末尾一定是3，7，9，1四者之一，然后我们再求出这么一串数相乘以后末尾的数是几，最后再补上 2对末位的影响即可。 所以，求n！最后非零位分为4步： (1)将n！中所有的2，5因子去掉 (2)求出剩下的一串数字相乘后末尾的那个数
> (3)由于2比5多，考虑多余的2对结果的影响 (4)输出答案 对于步骤(1)，直接计算去除就行了，很简单。
> 对于步骤(2)，是难点，这个问题可以转化为求出这些数里面末尾是3，7，9的数字出现的次数，因为这些数的n次方是有规律的，周期为4.
> 现在的问题就是如何求出这串数字末尾3，7，9各自出现的次数了。 一个数列实际上可以分为偶数列和奇数列。
> 例如：1*2*3*4*5*6*7*8*9*10 分成：1，3，5，7，9和2，4，6，8，10两部分
> 这样我们尝试分别进行统计，可以发现，实际上2，4，6，8，10中的个数也就是1，2，3，4，5中的个数，也就是说我们又把这个问题划分成了一个原来问
> 题的子问题。
> f(n)=f(n/2)+g(n)，g(n)表示奇数列中的数目，我们需要解决g(n)，再次观察g(n)，实际上又分成了两部分：1，3，7，9，11，13，17，19，21....................
> 以及5的奇倍数5，15，25，........ 说明又出现了子问题。 如果要统计这个数列中末尾为x(x为1，3，7，9)的个数可以这样写：
> g(n,x)=n/10+(n%10>=x)+g(n/5,x)
> 这样利用了两个递归方程，我们可以在logn的时间内计算出末尾为1，3，7，9的数的个数了
> 在得到这串数字中末尾是3，7，9的数字个数后，再利用循环节的性质可以快速求出这串数字相乘后mod10的结果，再考虑当时多余的2，便可以求出答案。
> 知道了这个之后，求A(n,m)就不难了。 先求出n！和(n-m)!中2，5，3，7，9分别出现的次数，然后各自相减，再用循环节处理即可。
> 这里还要注意一下：2的出现次数如果小于5的出现次数，我们可以直接输出5，如果2的出现次数等于5的出现次数，那么2的循环节不需要考虑。至于3，
> 7，9的循环节，由于这些数的4次方末尾刚好为1，所以不需要特殊考虑

题目：n!的最后的非零数字

``` cpp
#include<stdio.h>  
#include<string.h>  
  
#define maxn 10001  
  
const int mod[20]={1,1,2,6,4,2,2,4,2,8,4,4,8,4,6,8,8,6,8,2};  
  
int lastdigit(char buf[])  
{  
    int len=strlen(buf),a[maxn],i,c,ret=1;  
    if(len==1)return mod[buf[0]-'0'];  
    for(i=0;i<len;i++)  
        a[i]=buf[len-1-i]-'0';  
    while(len)  
    {  
        ret=ret*mod[a[1]%2*10+a[0]]%5;  
        for(c=0,i=len-1;i>=0;i--)  
        {  
            c=c*10+a[i],a[i]=c/5,c%=5;  
        }  
        len-=!a[len-1];  
    }  
    return ret+ret%2*5;  
}  
  
int main()  
{  
    char  n[maxn];  
    while(scanf("%s",n)!=EOF)  
    {  
        printf("%d\n",lastdigit(n));  
    }  
    return 0;  
}  


```


题目：求A(n,m)最后的非零位数字。

``` cpp
#include <iostream>  
  
using namespace std;  
  
int GetCount(int n,int x)    /**计算n!中质因子x出现的次数*/  
{  
    if(n==0) return 0;  
    return n/x+GetCount(n/x,x);  
}  
  
int g(int n,int x)           /**计算f(1)到f(n)中奇数数列中末尾为x的数出现的次数*/  
{  
    if(n==0) return 0;  
    return n/10+(n%10>=x)+g(n/5,x);  
}  
  
int getx(int n,int x)        /**计算f(1)到f(n)中，末尾为x的数的出现次数*/  
{  
    if(n==0) return 0;  
    return getx(n/2,x)+g(n,x);  
}  
  
int table[4][4]=  
{  
     6,2,4,8,  
     1,3,9,7,  
     1,7,9,3,  
     1,9,1,9  
};  
  
int main()  
{  
    int n,m;  
    int num2,num3,num5,num7,num9;  
    while(cin>>n>>m)  
    {  
        num2=GetCount(n,2)-GetCount(n-m,2);  
        num5=GetCount(n,5)-GetCount(n-m,5);  
        num3=getx(n,3)-getx(n-m,3);  
        num7=getx(n,7)-getx(n-m,7);  
        num9=getx(n,9)-getx(n-m,9);  
        int ans=1;  
        if(num5>num2)  
        {  
            cout<<"5"<<endl;  
            continue;  
        }  
        if(num2!=num5)  
        {  
            ans*=table[0][(num2-num5)%4];  
            ans%=10;  
        }  
        ans*=table[1][num3%4];  
        ans%=10;  
        ans*=table[2][num7%4];  
        ans%=10;  
        ans*=table[3][num9%4];  
        ans%=10;  
        cout<<ans<<endl;  
    }  
    return 0;  
}  
```
题目：求C(n,m)最后的非零位数字。

``` cpp
#include <iostream>  
  
using namespace std;  
  
int GetCount(int n,int x)    /**计算n!中质因子x出现的次数*/  
{  
    if(n==0) return 0;  
    return n/x+GetCount(n/x,x);  
}  
  
int g(int n,int x)           /**计算f(1)到f(n)中奇数数列中末尾为x的数出现的次数*/  
{  
    if(n==0) return 0;  
    return n/10+(n%10>=x)+g(n/5,x);  
}  
  
int getx(int n,int x)        /**计算f(1)到f(n)中，末尾为x的数的出现次数*/  
{  
    if(n==0) return 0;  
    return getx(n/2,x)+g(n,x);  
}  
  
int table[4][4]=  
{  
     6,2,4,8,  
     1,3,9,7,  
     1,7,9,3,  
     1,9,1,9  
};  
  
int main()  
{  
    int n,m;  
    int num2,num3,num5,num7,num9;  
    while(cin>>n>>m)  
    {  
        num2=GetCount(n,2)-GetCount(n-m,2)-GetCount(m,2);  
        num5=GetCount(n,5)-GetCount(n-m,5)-GetCount(m,5);  
        num3=getx(n,3)-getx(n-m,3)-getx(m,3);  
        num7=getx(n,7)-getx(n-m,7)-getx(m,7);  
        num9=getx(n,9)-getx(n-m,9)-getx(m,9);  
        int ans=1;  
        if(num5>num2)  
        {  
            cout<<"5"<<endl;  
            continue;  
        }  
        if(num2!=num5)  
        {  
            ans*=table[0][(num2-num5)%4];  
            ans%=10;  
        }  
        ans*=table[1][(num3%4+4)%4];  
        ans%=10;  
        ans*=table[2][(num7%4+4)%4];  
        ans%=10;  
        ans*=table[3][(num9%4+4)%4];  
        ans%=10;  
        cout<<ans<<endl;  
    }  
    return 0;  
}  
```

### 大数开方模板

``` cpp
#include <stdio.h>  
#include <string.h>  
#include <stdlib.h>  
  
#define DEPTH 10  
  
typedef int BigInteger[10100];  
  
int comp(const BigInteger a,const int c,const int d,const BigInteger b) //大数比较  
{  
    int i,t=0,O=-DEPTH*2;  
    if(b[0]-a[0]<d&&c) return 1;  
    for(i=b[0];i>d;i--)  
    {  
        t=t*DEPTH+a[i-d]*c-b[i];  
        if(t>0) return 1;  
        if(t<O) return 0;  
    }  
    for(i=d;i;i--)  
    {  
        t=t*DEPTH-b[i];  
        if(t>0) return 1;  
        if(t<O) return 0;  
    }  
    return t>0;  
}  
  
void sub(BigInteger a,const BigInteger b,const int c,const int d) //大数减  
{  
    int i,O=b[0]+d;  
    for(i=1+d;i<=O;i++)  
        if((a[i]-=b[i-d]*c)<0)  
            a[i+1]+=(a[i]-DEPTH+1)/DEPTH,a[i]-=(a[i]-DEPTH+1)/DEPTH*DEPTH;  
    for(;a[i]<0;a[i+1]+=(a[i]-DEPTH+1)/DEPTH,a[i]-=(a[i]-DEPTH+1)/DEPTH*DEPTH,i++);  
    for(;!a[a[0]]&&a[0]>1;a[0]--);  
}  
  
void Sqrt(BigInteger b,BigInteger a) //开平方  
{  
    int h,l,m,i;  
    memset((void*)b,0,sizeof(BigInteger));  
    for(i= b[0]=(a[0]+1)>>1;i;sub(a,b,m,i-1),b[i]+=m,i--)  
        for(h=DEPTH-1,l=0,b[i]=m=(h+l+1)>>1;h>l;b[i]=m=(h+l+1)>>1)  
            if(comp(b,m,i-1,a)) h=m-1;  
            else l = m;  
    for(;!b[b[0]]&&b[0]>1;b[0]--);  
    for (i = 1; i <= b[0]; b[i++] >>= 1);  
}  
  
char str[10100];  
BigInteger a,b;  
  
int main()  
{  
    int t;  
    scanf("%d", &t);  
    while(t--)  
    {  
        scanf("%s",str);  
        a[0]=strlen(str);  
        for(int i=1; i<=a[0]; i++)  
            a[i]=str[a[0]-i]-'0';  
        Sqrt(b,a);  
        for(int i=b[0]; i>=1; i--)  
            printf("%d",b[i]);  
        printf("\n");  
        if(t)  
            puts("");  
    }  
    return 0;  
}  
```
### 高精度进制转换
数字以a进制的形式给出，要求转化为b进制输出

``` cpp
#include <stdio.h>  
#include <string.h>  
#include <stdlib.h>  
  
#define MAXSIZE 60000  
  
char in[MAXSIZE];  
int oldbase,newbase;  
int a[MAXSIZE],b[MAXSIZE],r[MAXSIZE];  
  
inline int getNum(char c)  
{  
    if(c >= '0' && c <= '9') return c - '0';  
    if(c >= 'A' && c<= 'Z' ) return c - 'A' + 10;  
    return c - 'a' + 36;  
}  
  
inline char getChar(int i)  
{  
    if(i >= 0 && i <= 9) return i + '0';  
    if(i >= 10 && i <= 35) return i - 10 + 'A';  
    return i - 36 + 'a';  
}  
  
inline void chToNum()  
{  
    a[0] = strlen(in);  
    for(int i=1;i<=a[0];i++)  
    {  
        a[i] = getNum(in[i-1]);  
    }  
}  
  
void alter()  
{  
    while(a[0] >= 1)  
    {  
        int i,t = 0;  
        for(i=1;i<=a[0];i++)  
        {  
            t = t * oldbase + a[i];  
            b[ ++b[0] ] = t / newbase;  
            t %= newbase;  
        }  
        r[ ++r[0] ] = t;  
        b[0] = a[0];  
        for(i = 1; i <= b[0] && !b[i]; i++) ;  
        for(a[0] = 0; i <= b[0]; i++) a[ ++a[0] ] = b[i];  
        memset(b,0,sizeof(b));  
    }  
}  
  
void print()  
{  
    printf("%d %s\n%d ",oldbase,in,newbase);  
    while(r[0]>=1)  
    {  
        printf("%c",getChar(r[ r[0]-- ]));  
    }  
    printf("\n\n");  
}  
  
int main()  
{  
    int n;  
    while(scanf("%d",&n)!=EOF)  
    {  
        while(n--)  
        {  
            scanf("%d %d %s",&oldbase,&newbase,in);  
            chToNum();  
            alter();  
            print();  
        }  
    }  
    return 0;  
}  
```
### 动态区间求第k大的数字
题意：N<=50000 M<=10000，给定一个数组A[1]~A[N]，有M个操作
每个操作可以如下
Q i j t 输出 A[I]~A[J]之间第t小的数
C i t 将A[I]赋值为t

``` cpp
#include <cstdio>  
#include <cstring>  
#include <cstdlib>  
#include <iostream>  
#include <algorithm>  
  
using namespace std;  
  
#define N 60010  
#define M 10010  
#define INF 1000000000  
  
char ctrl[M][3];  
int cnt,n,m;  
int P[M],Q[M],a[N],b[N],K[M];  
  
struct treap  
{  
   int key,wei,cnt,size,ch[2];  
}T[N * 15];  
  
int tree[N << 1],nodecnt,root;  
  
void init()  
{  
   T[0].size = 0;  
   T[0].wei = -INF;  
   nodecnt = root = 0;  
}  
  
int ID(int l,int r)  
{  
    return l + r | l != r;  
}  
  
void update(int x)  
{  
   T[x].size = T[T[x].ch[0]].size + T[T[x].ch[1]].size + T[x].cnt;  
}  
  
void rotate(int &x,int t)  
{  
   int y = T[x].ch[t];  
   T[x].ch[t] = T[y].ch[!t];  
   T[y].ch[!t] = x;  
   update(x);  
   update(y);  
   x = y;  
}  
  
void insert(int &x,int t)  
{  
   if (!x)  
   {  
       x = ++ nodecnt;  
       T[x].key = t;  
       T[x].wei = rand();  
       T[x].cnt = 1;  
       T[x].ch[0] = T[x].ch[1] = 0;  
   }  
   else if (T[x].key == t)  
       T[x].cnt ++;  
   else  
   {  
       int k = T[x].key < t;  
       insert(T[x].ch[k],t);  
       if (T[x].wei < T[T[x].ch[k]].wei)  
           rotate(x,k);  
   }  
   update(x);  
}  
  
void erase(int &x,int t)  
{  
   if (T[x].key == t)  
   {  
       if (T[x].cnt == 1)  
       {  
           if (!T[x].ch[0] && !T[x].ch[1])  
           {  
               x = 0;  
               return;  
           }  
           rotate(x,T[T[x].ch[0]].wei < T[T[x].ch[1]].wei);  
           erase(x,t);  
       }  
       else T[x].cnt--;  
   }  
   else  
       erase(T[x].ch[T[x].key < t],t);  
   update(x);  
}  
  
int select(int x,int t)  
{  
   if (!x) return 0;  
   if (T[x].key > t) return select(T[x].ch[0],t);  
   return T[x].cnt + T[T[x].ch[0]].size + select(T[x].ch[1],t);  
}  
  
void treeins(int l,int r,int i,int x)  
{  
   insert(tree[ID(l,r)],x);  
   if (l == r) return;  
   int m = l + r >> 1;  
   if (i <= m) treeins(l,m,i,x);  
   else treeins(m + 1,r,i,x);  
}  
  
void treedel(int l,int r,int i,int x)  
{  
   erase(tree[ID(l,r)],x);  
   if (l == r) return;  
   int m = l + r >> 1;  
   if (i <= m) treedel(l,m,i,x);  
   else treedel(m + 1,r,i,x);  
}  
  
int query(int l,int r,int x,int y,int t)  
{  
   if (l == r) return l;  
   int m = l + r >> 1;  
   int ans = select(tree[ID(l,m)],y) - select(tree[ID(l,m)],x);  
   if (ans >= t) return query(l,m,x,y,t);  
   return query(m + 1,r,x,y,t - ans);  
}  
  
int main()  
{  
   int Times;  
   scanf("%d",&Times);  
   while (Times --)  
   {  
       scanf("%d%d",&n,&m);  
       memset(tree,0,sizeof tree);  
       init();  
       cnt = 0;  
       for (int i = 1;i <= n;i ++)  
           scanf("%d",&a[i]),b[++ cnt] = a[i];  
       for (int i = 1;i <= m;i ++)  
       {  
           scanf("%s%d%d",ctrl[i],&P[i],&Q[i]);  
           if (ctrl[i][0] == 'Q')  
               scanf("%d",&K[i]);  
           else  
               b[++ cnt] = Q[i];  
       }  
       sort(b + 1,b + 1 + cnt);  
       cnt = unique(b + 1,b + 1 + cnt) - b - 1;  
       for (int i = 1;i <= n;i ++)  
       {  
           a[i] = lower_bound(b + 1,b + 1 + cnt,a[i]) - b;  
           treeins(1,cnt,a[i],i);  
       }  
       for(int i = 1;i <= m;i ++)  
       {  
           if (ctrl[i][0] == 'Q')  
           {  
               int id = query(1,cnt,P[i] - 1,Q[i],K[i]);  
               printf("%d\n",b[id]);  
           }  
           else  
           {  
               treedel(1,cnt,a[P[i]],P[i]);  
               a[P[i]] = lower_bound(b + 1,b + 1 + cnt,Q[i]) - b;  
               treeins(1,cnt,a[P[i]],P[i]);  
           }  
       }  
   }  
   return 0;  
}  


```

### 线段树
线段树整体维护的是从1到n下标的元素(当然也可以维护0到n-1号元素或者其他任意一个区间的元素)但是拥有1到大约`3*n`的树节点，每个树节点维护一段[L，R]的区间内所有的元素信息(没有0号树节点,因为如果你要指定0号树节点为根的话，那么i号树节点的左右儿子就不是`i*2`节点和`i*2+1`节点了)。而树节点中每个节点i都有它需要维护的区间[l, r]。

对于实际的问题，比如求区间和，我们可以通过查询对应节点的sum[i]值得到回答。比如求区间颜色覆盖种类，我们也可以通过查询覆盖区间的对应信息，然后做统计而得出。也就是说：问题的解答要么存在于节点维护的信息中，要么存在于query的一次查询统计过程中。

在做线段树问题时，首先要考虑线段树每个树节点需要维护什么信息？之后考虑如何通过线段树维护的节点信息来解决我们要求得问题？

``` cpp
#include<cstdio>  
#include<cstring>  
using namespace std;  
const int maxn=50000+5;  
  
//线段树需要维护的信息  
int sum[maxn*4];  
#define lson i*2, l, m  
#define rson i*2+1, m+1, r  
  
//i节点收集子节点的统计结果  
void PushUp(int i)  
{  
    sum[i]=sum[i*2]+sum[i*2+1];  
}  
  
//递归建立线段树  
void build(int i,int l,int r)  
{  
    if(l==r)  
    {  
        scanf("%d",&sum[i]);  
        return ;  
    }  
  
    int m=(l+r)/2;  
    build(lson);  
    build(rson);  
    PushUp(i);//收集子节点的结果  
}  
  
//在当前区间[l, r]内查询区间[ql, qr]间的目标值  
//且能执行这个函数的前提是：[l,r]与[ql,qr]的交集非空  
//其实本函数返回的结果也是 它们交集的目标值  
int query(int ql,int qr,int i,int l,int r)  
{  
    //目的区间包含当前区间  
    if(ql<=l && r<=qr) return sum[i];  
  
    int m=(l+r)/2;  
    int res=0;  
    if(ql<=m) res += query(ql,qr,lson);  
    if(m<qr) res += query(ql,qr,rson);  
    return res;  
}  
  
//update这个函数就有点定制的意味了  
//本题是单点更新，所以是在区间[l,r]内使得第id数的值+val  
//如果是区间更新，可以update的参数需要将id变为ql和qr  
void update(int id,int val,int i,int l,int r)  
{  
    if(l==r)  
    {  
        sum[i] += val;  
        return ;  
    }  
  
    int m=(l+r)/2;  
    if(id<=m) update(id,val,lson);  
    else update(id,val,rson);  
    PushUp(i);//时刻记住维护i节点统计信息正确性  
}  
  
  
int main()  
{  
    int T;  
    scanf("%d",&T);  
    for(int kase=1; kase<=T; kase++)  
    {  
        printf("Case %d:\n",kase);  
  
        int n;//节点总数  
        scanf("%d",&n);  
        build(1,1,n);//建立线段树  
  
        char str[20];  
        int u,v;  
        while(scanf("%s",str)==1 && str[0]!='E')  
        {  
            scanf("%d%d",&u,&v);  
  
            if(str[0]=='Q') printf("%d\n",query(u,v,1,1,n));  
            else if(str[0]=='A') update(u,v,1,1,n);  
            else update(u,-v,1,1,n);  
        }  
    }  
    return 0;  
}  
```


### Splay树

``` cpp
/* 
 * POJ 3468 A Simple Problem with Integers 
 * 经典的线段树题目，用splay tree来作为入门题 
 * 成段更新+区间求和 
 * 题目给定了n个数A1,A2,...An，有以下两种操作 
 * C a b c:把c加入到Aa,Aa+1,..Ab中 
 * Q a b:查询Aa,Aa+1,..Ab的和 
 * 需要的变量：pre,ch,size(这三个基本都要),key(保存结点的值),sum(子树值和),add(增量的标记) 
 * (一般标记类，正确的做法都是要先更新掉该点，标记是标记没有更新子结点) 
 */  
  
#include <iostream>  
#include <stdio.h>  
#include <string.h>  
#include <algorithm>  
using namespace std;  
#define Key_value ch[ch[root][1]][0]  
const int MAXN=100010;  
int pre[MAXN],ch[MAXN][2],size[MAXN],root,tot1;//父结点、左右孩子、子树规模、根结点、结点数量  
int key[MAXN];//该点的值  
int add[MAXN];//增量的延迟标记  
long long sum[MAXN];//子树的和  
int s[MAXN],tot2;//内存池、内存池容量（这题用不到，如果有删除操作，内存不够可以这样  
//s中存的是被回收的内存,从后面可以看到,tot2不为0的时候优先使用s[tot2]=x中的pre[x],ch[x],size[x]等,  
//否则就使用tot1++之后产生的数x的对应位置  
int a[MAXN];//初始的数组，建树时候用  
int n,q;  
//debug部分  
void Treavel(int x)  
{  
    if(x)  
    {  
        Treavel(ch[x][0]);  
        printf("结点%2d:左儿子 %2d 右儿子 %2d 父结点 %2d size=%2d,key=%2d add=%2d sum=%I64d\n",x,ch[x][0],ch[x][1],pre[x],size[x],key[x],add[x],sum[x]);  
        Treavel(ch[x][1]);  
    }  
}  
void debug()  
{  
    printf("root:%d\n",root);  
    Treavel(root);  
}  
//以上是debug  
void NewNode(int &r,int father,int k)//一个是调用的时候注意变量顺序，还有r必须引用&  
{  
    if(tot2)r=s[tot2--];//取得时候是tot2--,那么存的时候就要是++tot2,tot2与tot1都是从1开始计数的  
    else r=++tot1;  
    pre[r]=father;  
    size[r]=1;//这个不能忘记 ,一定是1，否则可能出错  
    key[r]=k;  
    add[r]=0;  
    sum[r]=0;  
    ch[r][0]=ch[r][1]=0;  
}  
//给r为根的子树增加值，一定把当前结点的全部更新掉，再加个延迟标记表示儿子结点没有更新  
void Update_Add(int r,int ADD)  
{  
    if(r==0)return;  
    add[r]+=ADD;  
    key[r]+=ADD;  
    sum[r]+=(long long)ADD*size[r];  
}  
//通过孩子结点更新父亲结点  
void Push_Up(int r)  
{  
    size[r]=size[ch[r][0]]+size[ch[r][1]]+1;  
    sum[r]=sum[ch[r][0]]+sum[ch[r][1]]+key[r];  
}  
//将延迟标记更新到孩子结点  
void Push_Down(int r)  
{  
    if(add[r])  
    {  
        Update_Add(ch[r][0],add[r]);  
        Update_Add(ch[r][1],add[r]);  
        add[r]=0;  
    }  
}  
//建树区间[l,r]  
//先建立中间结点，再两端的方法  
void Build(int &x,int l,int r,int father)  
{  
    if(l>r)return;  
    int mid=(l+r)/2;  
    NewNode(x,father,a[mid]);  
    Build(ch[x][0],l,mid-1,x);  
    Build(ch[x][1],mid+1,r,x);  
    Push_Up(x);  
}  
//初始化，前后各加一个king结点  
void Init()  
{  
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);  
    root=tot1=tot2=0;  
    ch[root][0]=ch[root][1]=pre[root]=size[root]=add[root]=sum[root]=0;  
    key[root]=0;  
    NewNode(root,0,-1);  
    NewNode(ch[root][1],root,-1);//头尾各加入一个空位  
    Build(Key_value,1,n,ch[root][1]);  
    Push_Up(ch[root][1]);  
    Push_Up(root);  
}  
//旋转，0为左旋，1为右旋  该部分基本固定  
void Rotate(int x,int kind)  
{  
    int y=pre[x];  
    Push_Down(y);  
    Push_Down(x);//先把y的标记向下传递，再把x的标记往下传递  
    ch[y][!kind]=ch[x][kind];  
    pre[ch[x][kind]]=y;  
    if(pre[y])  
        ch[pre[y]][ch[pre[y]][1]==y]=x;  
    pre[x]=pre[y];  
    ch[x][kind]=y;  
    pre[y]=x;  
    Push_Up(y);//维护y结点   x节点的信息不用PushUp吗?可以证明这里除了x节点维护的信息不对外,其他所有点信息都正确  
    //Push_Up(x);//这个可以不写,详见Crash:运用伸展树解决数列维护问题 论文,但是写了也不会多多少时间消耗  
}  
//Splay调整，将结点r调整到goal下面  
void Splay(int r,int goal)  
{  
    Push_Down(r);  
    while(pre[r]!=goal)  
    {  
        if(pre[pre[r]]==goal)  
            Rotate(r,ch[pre[r]][0]==r);  
        else  
        {  
            int y=pre[r];  
            int kind=ch[pre[y]][0]==y;  
            if(ch[y][kind]==r)//之字形  
            {  
                Rotate(r,!kind);  
                Rotate(r,kind);  
            }  
            else               //一字型  
            {  
                Rotate(y,kind);  
                Rotate(r,kind);  
            }  
        }  
    }  
    Push_Up(r);  
    if(goal==0)root=r;  
}  
//得到第k个结点编号  
int Get_Kth(int r,int k)  
{  
    Push_Down(r);  
    int t=size[ch[r][0]]+1;  
    if(t==k)return r;  
    if(t>k)return Get_Kth(ch[r][0],k);  
    else return Get_Kth(ch[r][1],k-t);  
}  
int Get_Min(int r)//得到以r为根的第一个节点编号  
{  
    Push_Down(r);  
    while(ch[r][0])  
    {  
        r=ch[r][0];  
        Push_Down(r);  
    }  
    return r;  
}  
int Get_Max(int r)//得到以r为根的最后一个节点编号  
{  
    Push_Down(r);  
    while(ch[r][1])  
    {  
        r=ch[r][1];  
        Push_Down(r);  
    }  
    return r;  
}  
//区间增加一个值  
//注意因为在前面增加了个结点，所以把第l个结点旋转到根结点，第r+2个结点旋转到根结点的右孩子，  
//那么Key_value(ch[ch[root][1]][0]刚好就是区间[l,r]  
void ADD(int l,int r,int D)  
{  
    Splay(Get_Kth(root,l),0);//第l个点到根结点  
    Splay(Get_Kth(root,r+2),root);//第r+2个点到根结点的右孩子  
    Update_Add(Key_value,D);  
    Push_Up(ch[root][1]);  
    Push_Up(root);  
}  
//查询区间的和  
long long Query_Sum(int l,int r)  
{  
    Splay(Get_Kth(root,l),0);//第l个点到根结点  
    Splay(Get_Kth(root,r+2),root);//第r+2个点到根结点的右孩子  
    return sum[Key_value];  
}  
  
int main()  
{  
    //freopen("in.txt","r",stdin);  
    //freopen("out.txt","w",stdout);  
    while(scanf("%d%d",&n,&q)==2)  
    {  
        Init();//这个不能忘记  
        while(q--)  
        {  
            char op[20];  
            int x,y,z;  
            scanf("%s",op);  
            if(op[0]=='Q')  
            {  
                scanf("%d%d",&x,&y);  
                printf("%I64d\n",Query_Sum(x,y));  
            }  
            else  
            {  
                scanf("%d%d%d",&x,&y,&z);  
                ADD(x,y,z);  
            }  
        }  
    }  
    return 0;  
}  
```

### 并查集
题意： 给出一个有N`（0<N<=10000）`个顶点的无向图(顶点编号0到N-1), 然后依次给出它的M`（0<M<=100000）`条边，要求依次输出当删除给出的前k（1<=K<=M）条边后，该图的连通分量总数。
输入：第一行是N和M，然后是M行数`（X,Y）（0<=X,Y<N）`表示X与Y有边。
输出：依次输出所求的连通分量数。

分析：
当删除前K条边时图所剩的连通分量数 就是 N个点孤立时只添加后M-K条边时，所具有的连通分量数。
所以仅需倒序插入每条边，分别保存插入边后新图所具有的连通分量数目在数组内，然后输出数组即可。
进阶1：如果题目要求每次输出删除前i条边后的连通分量数目且i是随机给的呢？ 只需要将所有i按从大到小排序，然后离线处理所有的i询问之后按序输出所有结果就行。
进阶2：如果题目要求在线处理每条请求呢？即要求及时给出每个i对应的连通分量数目。只需要预处理所有可能的i询问结果，然后输出指定询问结果即可。

``` cpp
#include<cstdio>  
#include<cstring>  
#include<algorithm>  
using namespace std;  
const int maxn=10000+5;  
const int maxm=100000+5;  
  
int n,m;  
int ans[maxm];//ans[i]==x表删除前i条边所具有的连通分量  
struct Edge//边  
{  
    int u,v;  
}edges[maxm];  
  
//并查集  
int fa[maxn];  
int findset(int x){ return fa[x]==-1?x:fa[x]=findset(fa[x]); }  
int bind(int u,int v)  
{  
    int fu=findset(u);  
    int fv=findset(v);  
    if(fu!=fv)  
    {  
        fa[fu]=fv;  
        return 1;  
    }  
    return 0;  
}  
  
int main()  
{  
    while(scanf("%d%d",&n,&m)==2)  
    {  
        memset(fa,-1,sizeof(fa));  
        for(int i=1;i<=m;i++)  
            scanf("%d%d",&edges[i].u,&edges[i].v);  
  
        ans[m]=n;  
        for(int i=m-1;i>=0;i--)  
        {  
            int u=edges[i+1].u, v=edges[i+1].v;  
            ans[i]=ans[i+1]-bind(u,v);  
        }  
  
        for(int i=1;i<=m;i++)  
            printf("%d\n",ans[i]);  
    }  
    return 0;  
}  
```


### 动态树LinkCutTree模板

``` cpp
#include <cstdio>  
#include <algorithm>  
#include <iostream>  
#include <string.h>  
#include <stdio.h>  
const int maxn=100011;  
const int INF=0x7fffffff;  
using namespace std;  
  
struct SplayTree  
{  
    int val,mn,lazy;  
    bool remark;  
    int ch[2],pre;  
};  
  
SplayTree *tree;  
int N;  
int val[maxn];  
  
void Init_Splay(int x)  
{  
    tree[x].ch[0]=tree[x].ch[1]=tree[x].pre=0;  
    tree[x].remark=0;  
    tree[x].val=val[x];  
    tree[x].mn=val[x];  
}  
  
bool IsRoot(int x)  
{  
    return !tree[x].pre || (tree[tree[x].pre].ch[0]!=x && tree[tree[x].pre].ch[1]!=x);  
}  
  
void DynamicTree(int n)  
{  
    N=n;  
    tree=new SplayTree[n+1];  
    for(int i=0; i<=n; i++) Init_Splay(i);  
    tree[0].val=-INF;  
    tree[0].mn=-INF;  
}  
  
void Inc(int x,int d)  
{  
    tree[x].val+=d;  
    tree[x].mn+=d;  
    tree[x].lazy+=d;  
}  
  
void Rev(int x)  
{  
    swap(tree[x].ch[0],tree[x].ch[1]);  
    tree[x].remark^=1;  
}  
  
void PushDown(int x)  
{  
    if(!x) return;  
    if(tree[x].lazy)  
    {  
        if(tree[x].ch[0]) Inc(tree[x].ch[0],tree[x].lazy);  
        if(tree[x].ch[1]) Inc(tree[x].ch[1],tree[x].lazy);  
        tree[x].lazy=0;  
    }  
    if(tree[x].remark)  
    {  
        if(tree[x].ch[0]) Rev(tree[x].ch[0]);  
        if(tree[x].ch[1]) Rev(tree[x].ch[1]);  
        tree[x].remark=0;  
    }  
}  
  
void Update(int x)  
{  
    if(!x) return;  
    tree[x].mn=tree[x].val;  
    if(tree[x].ch[0]) tree[x].mn=max(tree[tree[x].ch[0]].mn,tree[x].mn);  
    if(tree[x].ch[1]) tree[x].mn=max(tree[tree[x].ch[1]].mn,tree[x].mn);  
}  
  
void Rotate(int p,int c)  
{  
    int x=tree[p].pre,y=tree[x].pre;  
    tree[p].pre=y;  
    tree[x].pre=p;  
    if(y) if(x==tree[y].ch[0]) tree[y].ch[0]=p;  
        else if(x==tree[y].ch[1]) tree[y].ch[1]=p;  
    tree[x].ch[!c]=tree[p].ch[c];  
    if(tree[x].ch[!c]) tree[tree[x].ch[!c]].pre=x;  
    tree[p].ch[c]=x;  
    Update(x);  
}  
  
int stack[maxn];  
  
void Splay(int x)  
{  
    int top=1;  
    stack[0]=x;  
    for(int q=x; !IsRoot(q);) stack[top++]=(q=tree[q].pre);  
    while(top) PushDown(stack[--top]);  
    while(!IsRoot(x))  
    {  
        int q=tree[x].pre;  
        if(IsRoot(q)) if(tree[q].ch[0]==x) Rotate(x,1);  
            else Rotate(x,0);  
        else  
        {  
            if(q==tree[tree[q].pre].ch[0])  
                if(tree[q].ch[0]==x) Rotate(q,1),Rotate(x,1);  
                else Rotate(x,0),Rotate(x,1);  
            else if(x==tree[q].ch[1]) Rotate(q,0),Rotate(x,0);  
            else Rotate(x,1),Rotate(x,0);  
        }  
    }  
    Update(x);  
}  
  
int Head(int x)  
{  
    Splay(x);  
    for(PushDown(x); tree[x].ch[0]; x=tree[x].ch[0]) PushDown(x);  
    Splay(x);  
    return x;  
}  
  
int Expose(int x)  
{  
    int y;  
    for(y=0; x; x=tree[x].pre) Splay(x),PushDown(x),tree[x].ch[1]=y,Update(y=x);  
    return y;  
}  
  
void ChangeRoot(int x)  
{  
    Rev(Expose(x));  
}  
  
void Change(int x,int y,int val)  
{  
    ChangeRoot(y);  
    Expose(x);  
    Splay(x);  
    tree[x].val+=val;  
    tree[x].lazy+=val;  
    tree[x].mn+=val;  
//    PushDown(x);  
//    Update(x);  
}  
  
int AskMax(int x,int y)  
{  
    ChangeRoot(x);  
    Expose(y);  
    Splay(y);  
    return tree[y].mn;  
}  
  
void Link(int x,int y)//link操作即为链接两个树，那么要先进性expose操作，把到路径上的边都变为实边，这样才能进行把x调整到根部，进而通过更改祖先来进行链接  
{  
    ChangeRoot(x);  
    Splay(x);  
    tree[x].pre=y;  
}  
  
void Cut(int x,int y)  
{  
    ChangeRoot(y);  
    Splay(x);  
    if(tree[x].ch[0])  
    {  
        tree[tree[x].ch[0]].pre=tree[x].pre;  
        tree[x].pre=tree[x].ch[0]=0;  
    }  
    else tree[x].pre=0;  
}  
  
int LCA(int x,int y)  
{  
    int p=Head(Expose(x));  
    int q=Expose(y),w=Head(q);  
    if(p==w) return q;  
    return 0;  
}  
  
struct data  
{  
    int x,y;  
} a[maxn];  
  
int main()  
{  
    int n,m;  
    while(scanf("%d",&n)==1)  
    {  
        for(int i=1; i<n; i++) scanf("%d%d",&a[i].x,&a[i].y);  
        val[0]=val[n+1]=-INF;  
        for(int i=1; i<=n; i++) scanf("%d",&val[i]);  
        DynamicTree(n+1);  
        for(int i=1; i<n; i++) Link(a[i].x,a[i].y);  
        scanf("%d",&m);  
        for(int i=1; i<=m; i++)  
        {  
            int c;  
            int x,y,val;  
            scanf("%d",&c);  
            if(c==1)  
            {  
                scanf("%d%d",&x,&y);  
                if(!LCA(x,y)) Link(x,y);  
                else printf("-1\n");  
            }  
            else if(c==2)  
            {  
                scanf("%d%d",&x,&y);  
                if(LCA(x,y) && x!=y) Cut(y,x);  
                else printf("-1\n");  
            }  
            else if(c==3)  
            {  
                scanf("%d%d%d",&val,&x,&y);  
                if(LCA(x,y)) Change(x,y,val);  
                else printf("-1\n");  
            }  
            else if(c==4)  
            {  
                scanf("%d%d",&x,&y);  
                int tmp=LCA(x,y);  
                if(tmp) printf("%d\n",AskMax(x,y));  
                else printf("-1\n");  
            }  
        }  
        printf("\n");  
    }  
    return 0;  
}  
```

### 伸展树Splay模板

``` cpp
/****************************************** 
数据结构： 
Splay_Tree,伸展树; 
 
性质： 
伸展树是二叉查找树的一种改进; 
与二叉查找树一样,伸展树也具有有序性; 
即伸展树中的每一个节点x都满足： 
该节点左子树中的每一个元素都小于x; 
而其右子树中的每一个元素都大于x; 
与普通二叉查找树不同的是，伸展树可以自我调整; 
 
特点： 
伸展树并不是严格意义上的平衡树; 
也还是极有可能退化成线性结构,但伸展操作能使它的每一次操作近似(logn); 
 
伸展操作： 
伸展操作和平衡树的保持平衡是类似的; 
只不过他不要求保持平衡,只是相应的旋转; 
旋转有三种情况要处理： 
(1)Zig或Zag(节点x的父节点y是根节点) 
(2)Zig-Zig或Zag-Zag(节点x的父节点y不是根节点，且x与y同时是各自父节点的左孩子或者同时是各自父节点的右孩子) 
(3)Zig-Zag或Zag-Zig(节点x的父节点y不是根节点，x与y中一个是其父节点的左孩子而另一个是其父节点的右孩子) 
即一字型旋转和之字型旋转; 
 
优势： 
能快速定位一个区间[l,r]，并且能将区间进行删除、旋转操作; 
将第l-1个结点旋转至根(之前的Splay操作)，将第r+1个结点旋转至根的右孩子; 
由于伸展树的本质还是二叉搜索树,则根据二叉查找树的性质可以知道; 
在这两个结点之间，也是根的右孩子的左子树就包括节点[l,r]; 
即很快定位了区间[l,r]，如果需要删除，直接把子树拿走即可; 
 
算法测试： 
PKU3468(A Simple Problem with Integers) 
 
题目大意: 
Q a b   ：查询区间[a,b]的和; 
C a b x : 更新区间[a,b]，区间所有值加上x; 
*******************************************/  
#include<iostream>  
#include<cstring>  
#include<cstdio>  
#include<algorithm>  
using namespace std;  
  
#define Key_value ch[ch[root][1]][0]//进行各种操作的区间  
  
const int INF=0xffffff;  
const int N=100010;  
typedef long long LL;  
  
int ch[N][2];//左右孩子(0为左孩子，1为右孩子)  
int pre[N];//父结点  
int key[N];//数据域  
int size[N];//树的规模  
int val[N];  
int add[N];  
int a[N];//结点元素  
LL sum[N];//子树结点和  
int root;  //根结点  
int tot;//结点数量  
int n,q;  
  
void Push_Up(int u)//通过孩子结点更新父结点  
{  
    size[u]=size[ch[u][0]]+size[ch[u][1]]+1;  
    sum[u]=sum[ch[u][0]]+sum[ch[u][1]]+val[u]+add[u];  
}  
  
void Push_Down(int u)//将延迟标记更新到孩子结点  
{  
    if(add[u])  
    {  
        val[u]+=add[u];  
        add[ch[u][0]]+=add[u];  
        add[ch[u][1]]+=add[u];  
        sum[ch[u][0]]+=(LL)add[u]*size[ch[u][0]];  
        sum[ch[u][1]]+=(LL)add[u]*size[ch[u][1]];  
        add[u]=0;  
    }  
}  
  
void New_Node(int &u,int f,int c)//新建一个结点，f为父节点  
{  
    u=++tot;  
    val[u]=sum[u]=c;  
    pre[u]=f;  
    size[u]=1;  
    ch[u][1]=ch[u][0]=add[u]=0;  
}  
  
void Build_Tree(int &u,int l,int r,int f)//建树，中间结点先建立，然后分别对区间两端在左右子树建立  
{  
    if(l>r)  
        return;  
    int m=(l+r)>>1;  
    New_Node(u,f,a[m]);  
    if(l<m)  
        Build_Tree(ch[u][0],l,m-1,u);  
    if(r>m)  
        Build_Tree(ch[u][1],m+1,r,u);  
    Push_Up(u);  
}  
  
void Rotate(int x,int c)//旋转操作，c=0 表示左旋，c=1 表示右旋  
{  
    int y=pre[x];  
    Push_Down(y);// 先将Y结点的标记向下传递（因为Y在上面）  
    Push_Down(x);//再把X的标记向下传递  
    ch[y][!c]=ch[x][c];//类似SBT，要把其中一个分支先给父节点  
    pre[ch[x][c]]=y;  
    pre[x]=pre[y];  
    if(pre[y])//如果父节点不是根结点，则要和父节点的父节点连接起来  
    {  
        ch[pre[x]][ch[pre[y]][1]==y]=x;  
    }  
    pre[y]=x;  
    ch[x][c]=y;  
    Push_Up(y);  
}  
  
void Splay(int x,int f)//Splay操作,把根结点x转到结点f的下面  
{  
    Push_Down(x);  
    while(pre[x]!=f)  
    {  
        int y=pre[x];  
        if(pre[y]==f)//父结点的父亲即为f，执行单旋转  
            Rotate(x,ch[y][0]==x);  
        else  
        {  
            int z=pre[y];  
            int g=(ch[z][0]==y);  
            if(ch[y][g]==x)  
                Rotate(x,!g),Rotate(x,g);//之字形旋转  
            else Rotate(y,g),Rotate(x,g);//一字形旋转  
        }  
    }  
    Push_Up(x);// 最后再维护X结点  
    if(f==0)//更新根结点  
    {  
        root=x;  
    }  
}  
  
void Rotate_Under(int k,int f)//把第k位的数伸展到f下方  
{  
    //找到处在中序遍历第k个结点，并将其旋转到结点f 的下面  
    int p=root;//从根结点开始  
    Push_Down(p);// 由于要访问p的子结点，将标记下传  
    while(size[ch[p][0]]!=k)//p的左子树的大小  
    {  
        if(k<size[ch[p][0]])// 第k个结点在p左边，向左走  
        {  
            p=ch[p][0];  
        }  
        else//否则在右边,而且在右子树中，这个结点不再是第k个  
        {  
            k-=(size[ch[p][0]]+1);  
            p=ch[p][1];  
        }  
        Push_Down(p);  
    }  
    Splay(p,f);//执行旋转  
}  
  
int Insert(int k)//插入结点  
{  
    int r=root;  
    while(ch[r][key[r]<k])  
        r=ch[r][key[r]<k];  
    New_Node(ch[r][k>key[r]],r,k);  
    //将新插入的结点更新至根结点  
    //Push_Up(r);  
    Splay(ch[r][k>key[r]],0);  
    return 1;  
}  
  
int Get_Pre(int x)//找前驱，即左子树的最右结点  
{  
    int tmp=ch[x][0];  
    if(tmp==0)  
    return INF;  
    while(ch[tmp][1])  
    {  
        tmp=ch[tmp][1];  
    }  
    return key[x]-key[tmp];  
}  
  
int Get_Next(int x)//找后继，即右子树的最左结点  
{  
    int tmp=ch[x][1];  
    if(tmp==0)  
    return INF;  
    while(ch[tmp][0])  
    {  
        tmp=ch[tmp][0];  
    }  
    return key[tmp]-key[x];  
}  
  
LL Query(int l,int r)//查询[l,r]之间的和  
{  
    Rotate_Under(l-1,0);  
    Rotate_Under(r+1,root);  
    return sum[Key_value];  
}  
  
void Update(int l,int r)//更新  
{  
    int k;  
    scanf("%d",&k);  
    Rotate_Under(l-1,0);  
    Rotate_Under(r+1,root);  
    add[Key_value]+=k;  
    sum[Key_value]+=size[Key_value]*k;  
}  
  
void Init()//初始化  
{  
    for(int i=0; i<n; i++)  
        scanf("%d",&a[i]);  
    ch[0][0]=ch[0][1]=pre[0]=size[0]=0;  
    add[0]=sum[0]=0;  
    root=tot=0;  
    New_Node(root,0,-1);  
    New_Node(ch[root][1],root,-1);   //头尾各加入一个空位  
    size[root]=2;  
    Build_Tree(Key_value,0,n-1,ch[root][1]);  //让所有数据夹在两个-1之间  
    Push_Up(ch[root][1]);  
    Push_Up(root);  
}  
  
int main()  
{  
    while(~scanf("%d%d",&n,&q))  
    {  
        Init();  
        while(q--)  
        {  
            char op;  
            scanf(" %c",&op);  
            int x,y;  
            scanf("%d%d",&x,&y);  
            if(op=='Q')  
                printf("%lld\n",Query(x,y));  
            else  
                Update(x,y);  
        }  
    }  
    return 0;  
}  
```

### BST(Binary Search Tree 二叉查找树模版)

``` cpp
/****************************************** 
数据结构： 
BST(Binary Search Tree),二叉查找树; 
 
性质： 
若结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值; 
若结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值; 
该结点的左、右子树也分别为二叉查找树; 
 
遍历： 
对于一个已知的二叉查找树,从小到大输出其节点的值; 
只需对其进行二叉树的中序遍历即可; 
即递归地先输出其左子树,再输出其本身,然后输出其右子树; 
遍历的时间复杂度为O(n); 
 
查找： 
对于一个已知的二叉查找树x; 
在其中查找特定的值k,函数Search返回指向值为k的节点指针; 
若找不到则返回0,算法时间复杂度为O(h),h为树的高度; 
理想情况下时间复杂度为lgn; 
 
最大值和最小值： 
要查找二叉查找树中具有最小值的元素; 
只要从根节点开始,沿着左子树找到最左边的节点就可以了; 
反之沿着右子树查找则可以求最大值; 
 
插入： 
从根节点开始插入; 
如果要插入的值小于等于当前节点的值，在当前节点的左子树中插入; 
如果要插入的值大于当前节点的值，在当前节点的右子树中插入; 
如果当前节点为空节点，在此建立新的节点，该节点的值为要插入的值，左右子树为空，插入成功; 
 
删除： 
如果该没有子女，直接删除; 
如果该结点只有一个子女，则删除它，将其子女的父亲改为它的父亲; 
如果该结点有两个子女，先用其后继替换该节点，其后继的数据一并加在其后; 
*******************************************/  
#include<iostream>  
#include<cstring>  
#include<cstdlib>  
#include<cstdio>  
#include<climits>  
#include<algorithm>  
using namespace std;  
  
const int N = 100000;  
int key[N], l[N], r[N], p[N];  
int u, node;  
  
int Search(int x, int k)//查询  
{  
    if(x == 0 || k == key[x])  
        return x;  
    if(k < key[x])  
        return Search(l[x], k);  
    else  
        return Search(r[x], k);  
}  
  
int Iterative_Search(int x, int k)//非递归版本的查询  
{  
    while(x != 0 && k != key[x])  
        if(k < key[x])  
            x = l[x];  
        else  
            x = r[x];  
    return x;  
}  
  
int Minimum(int x)  
{  
    while(l[x] != 0)  
        x = l[x];  
    return x;  
}  
  
int Maximum(int x)  
{  
    while(r[x] != 0)  
        x = r[x];  
    return x;  
}  
  
int Successor(int x)  
{  
    if(r[x] != 0)  
        return Minimum(r[x]);  
    int y = p[x];  
    while(y != 0 && x == r[y])  
    {  
        x = y;  
        y = p[y];  
    }  
    return y;  
}  
  
int Predecessor(int x)  
{  
    if(l[x] != 0)  
        return Maximum(l[x]);  
    int y = p[x];  
    while(y != 0 && x == l[y])  
    {  
        x = y;  
        y = p[y];  
    }  
    return y;  
}  
  
void Insert(int &T, int v)//插入结点  
{  
    if(T == 0)  
        key[T = ++node] = v;  
    else if(v <= key[T])  
    {  
        p[l[T]] = T;  
        Insert(l[T], v);  
    }  
    else  
    {  
        p[r[T]] = T;  
        Insert(r[T], v);  
    }  
}  
  
void Iterative_Insert(int T, int v)//非递归版本插入结点  
{  
    int y = 0;  
    int x = T;  
    int z = ++node;  
    key[z] = v;  
    while(x != 0)  
    {  
        y = x;  
        if(key[z] < key[x])  
            x = l[x];  
        else  
            x = r[x];  
    }  
    p[z] = y;  
    if(y == 0)  
        key[T] = z;  
    else if(key[z] < key[y])  
        l[y] = z;  
    else  
        r[y] = z;  
}  
  
void Transplant(int T, int u, int v)//移植过程;  
//把一棵子树u归并到另一棵子树v中，u的父亲变为v的父亲，u的父亲就有了v作为其孩子。  
{  
    if(p[u] == 0)  
        T = v;  
    else if(u == l[p[u]])  
        l[p[u]] = v;  
    else  
        r[p[u]] = v;  
    if(v != 0)  
        p[v] = p[u];  
}  
  
void Delete(int T, int z)//删除结点  
{  
    if(l[z] == 0)  
        Transplant(T, z, r[z]);  
    else if(r[z] == 0)  
        Transplant(T, z, l[z]);  
    else  
    {  
        int y = Minimum(r[z]);  
        if(p[y] != z)  
        {  
            Transplant(T, y, r[y]);  
            r[y] = r[z];  
            p[r[y]] = y;  
        }  
        Transplant(T, z, y);  
        l[y] = l[z];  
        p[l[y]] = y;  
    }  
}  
  
  
int main()  
{  
    int n;  
    scanf("%d",&n);  
    for(int i=0; i<n; i++)  
    {  
        int k;  
        scanf("%d",&k);  
        Insert(u, k);  
    }  
    Delete(u, Search(u, 1));  
    printf("%d\n",Search(u,2));  
    printf("%d\n",Maximum(u));  
    return 0;  
}  
```
### SBT模版(Size Balanced Tree)

``` cpp
/************************************************* 
数据结构： 
SBT(Size Balanced Tree),又称傻逼树; 
 
数据域： 
值域key,左孩子left,右孩子right,保持平衡的size; 
 
性质： 
每棵子树的大小不小于其兄弟的子树大小; 
 
插入： 
插入算法先简单插入节点，然后调用一个维护过程以保持性质; 
 
删除： 
删除操作与普通维护size域的二叉查找树相同; 
 
最大值和最小值： 
由于SBT本身已经维护了size域; 
所以只需用Select(T,1)来求最大值; 
Select(T,T.size)求最小值; 
其中Select(T,k)函数返回树T在第k位置上的节点值; 
**************************************************/  
#include<iostream>  
#include<cstring>  
#include<cstdlib>  
#include<cstdio>  
#include<climits>  
#include<algorithm>  
using namespace std;  
  
const int N = 100000;  
int key[N], lefts[N], rights[N], size[N];  
int u;//根结点  
int node;  
  
inline void Left_Rotate(int &x)  
{  
    int k = rights[x];  
    rights[x] = lefts[k];  
    lefts[k] = x;  
    size[k] = size[x];  
    size[x] = size[lefts[x]] + size[rights[x]] + 1;  
    x = k;  
}  
  
inline void Right_Rotate(int &y)  
{  
    int k = lefts[y];  
    lefts[y] = rights[k];  
    rights[k] = y;  
    size[k] = size[y];  
    size[y] = size[lefts[y]] + size[rights[y]] + 1;  
    y = k;  
}  
  
void Maintain(int &u, bool flag)//维护  
{  
    if(flag == false)  
    {  
        if(size[lefts[lefts[u]]] > size[rights[u]])  
            Right_Rotate(u);  
        else  
        {  
            if(size[rights[lefts[u]]] > size[rights[u]])  
            {  
                Left_Rotate(lefts[u]);  
                Right_Rotate(u);  
            }  
            else return;  
        }  
    }  
    else  
    {  
        if(size[rights[rights[u]]] > size[lefts[u]])  
            Left_Rotate(u);  
        else  
        {  
            if(size[lefts[rights[u]]] > size[lefts[u]])  
            {  
                Right_Rotate(rights[u]);  
                Left_Rotate(u);  
            }  
            else return;  
        }  
    }  
    Maintain(lefts[u], false);  
    Maintain(rights[u], true);  
    Maintain(u, true);  
    Maintain(u, false);  
}  
  
void Insert(int &u, int v)//插入结点  
{  
    if(u == 0)  
    {  
        key[u = ++node] = v;  
        size[u] = 1;  
    }  
    else  
    {  
        size[u]++;  
        if(v < key[u])  
            Insert(lefts[u], v);  
        else  
            Insert(rights[u], v);  
        Maintain(u, v >= key[u]);  
    }  
}  
  
int Delete(int &u, int v)//删除结点  
{  
    size[u]--;  
    if( (v == key[u]) || (v < key[u] && lefts[u] == 0) || (v > key[u] && rights[u] == 0) )  
    {  
        int r = key[u];  
        if(lefts[u] == 0 || rights[u] == 0)  
            u = lefts[u] + rights[u];  
        else  
            key[u] = Delete(lefts[u], key[u] + 1);  
        return r;  
    }  
    else  
    {  
        if(v < key[u])  
            return Delete(lefts[u], v);  
        else  
            return Delete(rights[u], v);  
    }  
}  
  
int Search(int x, int k)//查询  
{  
    if(x == 0 || k == key[x])  
        return x;  
    if(k < key[x])  
        return Search(lefts[x], k);  
    else  
        return Search(rights[x], k);  
}  
  
int Select(int u, int k)//返回树在第k位置上的结点值  
{  
    int r = size[lefts[u]] + 1;  
    if(k == r)  
        return key[u];  
    else if(k < r)  
        return Select(lefts[u], k);  
    else  
        return Select(rights[u], k - r);  
}  
  
int Successor(int u, int k)//查询结点k的后继  
{  
    if(u == 0)  
        return k;  
    if(key[u] <= k)  
        return Successor(rights[u], k);  
    else  
    {  
        int r = Successor(lefts[u], k);  
        if(r == k)  
            return key[u];  
        else  
            return r;  
    }  
}  
  
int Predecessor(int u, int k)//查询结点k的前驱  
{  
    if(u == 0)  
        return k;  
    if(key[u] >= k)  
        return Predecessor(lefts[u], k);  
    else  
    {  
        int r = Predecessor(rights[u], k);  
        if(r == k)  
            return key[u];  
        else  
            return r;  
    }  
}  
  
int Rank(int u, int k)//排名(rank),也叫秩,求整棵树中从大到小排序的第k位元素;  
{  
    if(u==0)  
        return 1;  
    if(key[u] >= k)  
        return Rank(lefts[u], k);  
    else  
        return size[lefts[u]] + Rank(rights[u], k) + 1;  
}  
  
int main()  
{  
    int n;  
    scanf("%d",&n);  
    for(int i=0; i<n; i++)  
    {  
        int cmd,x;  
        scanf("%d%d",&cmd,&x);  
        switch(cmd)  
        {  
        case 1:  
            Insert(u,x);  
            break;  
        case 2:  
            Delete(u,x);  
            break;  
        case 3:  
            printf("%d\n", Search(u,x));  
            break;  
        case 4:  
            printf("%d\n", Rank(u,x));  
            break;  
        case 5:  
            printf("%d\n", Select(u,x));  
            break;  
        case 6:  
            printf("%d\n", Predecessor(u,x));  
            break;  
        case 7:  
            printf("%d\n", Successor(u,x));  
            break;  
        }  
    }  
    return 0;  
}  
```

### 划分树（求区间第k大）
求区间[p,q]的第K大就等于求区间[p,q]的第q-p+1-k小。

``` cpp
#include <iostream>  
#include <string.h>  
#include <algorithm>  
#include <stdio.h>  
  
using namespace std;  
const int N = 100005;  
  
int sorted[N];  
int Tree[20][N];  
int toLeft[20][N];  
  
void Build(int k,int l,int r)  
{  
    if(l==r) return;  
    int mid=(l+r)>>1;  
    int i,t;  
    t=mid-l+1;  
    for(i=l;i<=r;i++)  
       if(Tree[k][i]<sorted[mid])  
          t--;  
    int L=l;  
    int R=mid+1;  
    for(i=l;i<=r;i++)  
    {  
       if(i==l)  
          toLeft[k][i]=0;  
       else  
          toLeft[k][i]=toLeft[k][i-1];  
       if(Tree[k][i]<sorted[mid])  
       {  
           toLeft[k][i]++;  
           Tree[k+1][L++]=Tree[k][i];  
       }  
       else if(Tree[k][i]>sorted[mid])  
       {  
           Tree[k+1][R++]=Tree[k][i];  
       }  
       else  
       {  
           if(t!=0)  
           {  
               t--;  
               toLeft[k][i]++;  
               Tree[k+1][L++]=Tree[k][i];  
           }  
           else  
               Tree[k+1][R++]=Tree[k][i];  
       }  
    }  
    Build(k+1,l,mid);  
    Build(k+1,mid+1,r);  
}  
  
int Query(int k,int l,int r,int p,int q,int t)  
{  
    if(p==q) return Tree[k][p];  
    int s,ss;  
    int mid=(l+r)>>1;  
    if(l==p)  
    {  
        s=0;  
        ss=toLeft[k][q];  
    }  
    else  
    {  
        s=toLeft[k][p-1];  
        ss=toLeft[k][q]-s;  
    }  
    int L,R;  
    if(t<=ss)  
    {  
        L=l+s;  
        R=l+s+ss-1;  
        return Query(k+1,l,mid,L,R,t);  
    }  
    else  
    {  
        L=mid-l+1+p-s;  
        R=mid-l+1+q-s-ss;  
        return Query(k+1,mid+1,r,L,R,t-ss);  
    }  
}  
  
int main()  
{  
    int n,m,i,j;  
    while(~scanf("%d",&n))  
    {  
        for(i=1;i<=n;i++)  
        {  
            scanf("%d",&Tree[0][i]);  
            sorted[i]=Tree[0][i];  
        }  
        std::sort(sorted+1,sorted+n+1);  
        Build(0,1,n);  
        scanf("%d",&m);  
        int p,q,k;  
        while(m--)  
        {  
            scanf("%d%d%d",&p,&q,&k);  
            p++;q++;k--;  
            printf("%d\n",Query(0,1,n,p,q,q-p+1-k));  
        }  
    }  
    return 0;  
}  
```

### 求逆序数（线段树）

``` cpp
#include <stdio.h>  
#define maxn 55555  
  
#define lson l,m,rt<<1  
#define rson m+1,r,rt<<1|1  
  
int sum[maxn<<2];  
int x[maxn];  
  
int min(int a,int b)  
{  
    return a<b? a:b;  
}  
  
void PushUP(int rt)  
{  
    sum[rt]=sum[rt<<1]+sum[rt<<1|1];  
}  
  
void Build(int l,int r,int rt)  
{  
    sum[rt]=0;  
    if(l==r)  
        return;  
    int m=(l+r)>>1;  
    Build(lson);  
    Build(rson);  
}  
  
void Update(int p,int l,int r,int rt)  
{  
    if(l==r)  
    {  
        sum[rt]++;  
        return;  
    }  
    int m=(l+r)>>1;  
    if(p<=m)  
        Update(p,lson);  
    else  
        Update(p,rson);  
    PushUP(rt);  
}  
  
int Query(int L,int R,int l,int r,int rt)  
{  
    if(L<=l&&R>=r)  
        return sum[rt];  
    int m=(l+r)>>1;  
    int ret=0;  
    if(L<=m)      ret+=Query(L,R,lson);  
    if(R>m)       ret+=Query(L,R,rson);  
    return ret;  
}  
  
int main()  
{  
    int n,i;  
    while(~scanf("%d",&n))  
    {  
        Build(0,n-1,1);  
        int sum=0;  
        for(i=0;i<n;i++)  
        {  
            scanf("%d",&x[i]);  
            sum+=Query(x[i],n-1,0,n-1,1);  
            Update(x[i],0,n-1,1);  
        }  
        int ret=sum;  
        for(i=0;i<n;i++)  
        {  
            sum+=n-x[i]-x[i]-1;  
            ret=min(ret,sum);  
        }  
        printf("%d\n",ret);  
    }  
    return 0;  
}  
```

### ST算法解决RMQ问题

> 关于ST算法，实际上它本身并不难，它的思想是动态规划。主要用来求RMQ问题，时间复杂度为O(NlgN+M)  关于RMQ问题描述：
> 输入N个数和M次询问，每次询问一个区间[L,R],求第L个数到R个数之间的最大值，或者是求最小值。   它的原理阐述如下：
> 对于一个数组A[0...N-1]，我们用f[i][j]表示A[i]到A[i+2^j-1]，这个范围内的最大值。
> 由于此区间的元素个数很明显为2^j个，所以我们又可以从中间平分为两部分，这样每部分又有2^(j-1)个元素，这样我们就知道区间[i,i+2^j-1]可以分为[i,i+2^(j-1)-1]和[i+2^(j-1),i+2^j-1]两部分，我们只需要求出后面两个区间最大值的较大值，就可以知道前面区间的最大值了。
> 所以到了这里，很明显可以写出状态转移方程： f[i][j]=max(f[i][j-1]，f[i+2^(j-1)][j-1])
> 当然很明显知道初始化f[i][0]=A[i] 当然上面i，j的范围是多少呢？
> 现在我们来分析一下：我们已经说了如果用上述原理一个区间的元素是2^j个，而可以知道2^j<=N的，所以这样就得到j<=log(N)/log(2);
> 当然j还大于等于1 对于i，就直接有`i+2^j-1<N`就行了。 到了这里，我们就可以把f[i][j]求出来了。 接下来就是query()了。
> 这个怎么办呢，其实很容易，我们先求出满足条件2^x=R-L+1的最大x
> 这样我们我们就可以把区间[L,R]求最值问题转化为了求区间[L,L+2^x-1]和区间[R-2^x+1,R]最大值的较大值了，为什么可以这样做，因为这两个区间中间有重叠。
> 但是这两个区间的并一定等于区间[L,R]，所以到了这里ST算法的原理基本常阐述完毕了。 剩下的就是代码实现了。

``` cpp
#include <stdio.h>  
#include <math.h>  
#define N 1005  
  
int m,n;  
int a[N];  
int f[N][N];  
  
int max(int a,int b)  
{  
    return a>b? a:b;  
}  
  
void ST()  
{  
    int i,j;  
    for(i=0;i<n;i++)  
       f[i][0]=a[i];  
    for(j=1;j<=(int)((log((double)n)/log(2.0)));j++)  
    {  
        for(i=0;i+(1<<j)-1<n;i++)  
           f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);  
    }  
}  
  
int query(int L,int R)  
{  
    int x=(int)(log((double)(R-L+1))/log(2.0));  
    return max(f[L][x],f[R-(1<<x)+1][x]);  
}  
  
int main()  
{  
    int i,L,R;  
    while(~scanf("%d%d",&n,&m))  
    {  
        for(i=0;i<n;i++)  
           scanf("%d",&a[i]);  
        ST();  
        while(m--)  
        {  
            scanf("%d%d",&L,&R);  
            printf("%d\n",query(L-1,R-1));  
        }  
    }  
    return 0;  
}  
```
### Manacher算法
题意：给定一个长度不超过110000的字符串T，求它的最长回文子串。
求最长回文子串可以用后缀数组，扩展KMP算法，Manacher算法，其中Manacher算法无论时间还是编程复杂度都是最好的，其时间复杂度为O(n)

``` cpp
#include <iostream>  
#include <string.h>  
#include <stdio.h>  
  
using namespace std;  
const int N=200005<<1;  
  
char T[N];   //原字符串  
char S[N];   //转换后的字符串  
int  R[N];   //回文半径  
  
void Init(char *T)  
{  
    S[0]='$';  
    int len=strlen(T);  
    for(int i=0; i<=len; i++)  
    {  
        S[2*i+1]='#';  
        S[2*i+2]=T[i];  
    }  
}  
  
void Manacher(char *S)  
{  
    int k=0,mx=0;  
    int len=strlen(S);  
    for(int i=0; i<len; i++)  
    {  
        if(mx>i)  
            R[i]=R[2*k-i]<mx-i? R[2*k-i] : mx-i;  
        else  
            R[i]=1;  
        while(S[i+R[i]]==S[i-R[i]])  
            R[i]++;  
        if(R[i]+i>mx)  
        {  
            mx=R[i]+i;  
            k=i;  
        }  
    }  
}  
  
int main()  
{  
    while(~scanf("%s", T))  
    {  
        Init(T);  
        Manacher(S);  
        int len=strlen(S);  
        int ans=1;  
        for(int i=0; i<len; i++)  
            ans=R[i]>ans? R[i] : ans;  
        printf("%d\n", ans-1);  
    }  
    return 0;  
}  
```

### AC自动机
AC自动机算法分为3步：构造Trie树，构造失败指针和模式匹配过程。
AC自动机简介： 
首先简要介绍一下AC自动机：Aho-Corasick automation，该算法在1975年产生于贝尔实验室，是著名的多模匹配算法之一。一个常见的例子就是给出n个单词，再给出一段包含m个字符的文章，让你找出有多少个单词在文章里出现过。要搞懂AC自动机，先得有字典树Trie和KMP模式匹配算法的基础知识。KMP算法是单模式串的字符匹配算法，AC自动机是多模式串的字符匹配算法。
**AC自动机的构造：**
1.构造一棵Trie，作为AC自动机的搜索数据结构。
2.构造fail指针，使当前字符失配时跳转到具有最长公共前后缀的字符继续匹配。如同 KMP算法一样， AC自动机在匹配时如果当前字符匹配失败，那么利用fail指针进行跳转。由此可知如果跳转，跳转后的串的前缀，必为跳转前的模式串的后缀并且跳转的新位置的深度（匹配字符个数）一定小于跳之前的节点。所以我们可以利用 bfs在 Trie上面进行 fail指针的求解。
3.扫描主串进行匹配。
**AC自动机详讲：**
我们给出5个单词，say，she，shr，he，her。给定字符串为yasherhs。问多少个单词在字符串中出现过。
**一、Trie**
首先我们需要建立一棵Trie。但是这棵Trie不是普通的Trie，而是带有一些特殊的性质。
首先会有3个重要的指针，分别为p, p->fail, temp。
1.指针p，指向当前匹配的字符。若p指向root，表示当前匹配的字符序列为空。（root是Trie入口，没有实际含义）。
2.指针p->fail，p的失败指针，指向与字符p相同的结点，若没有，则指向root。
3.指针temp，测试指针（自己命名的，容易理解！~），在建立fail指针时有寻找与p字符匹配的结点的作用，在扫描时作用最大，也最不好理解。
对于Trie树中的一个节点，对应一个序列s[1...m]。此时，p指向字符s[m]。若在下一个字符处失配，即p->next[s[m+1]] == NULL，则由失配指针跳到另一个节点(p->fail)处，该节点对应的序列为s[i...m]。若继续失配，则序列依次跳转直到序列为空或出现匹配。在此过程中，p的值一直在变化，但是p对应节点的字符没有发生变化。在此过程中，我们观察可知，最终求得得序列s则为最长公共后缀。另外，由于这个序列是从root开始到某一节点，则说明这个序列有可能是某些序列的前缀。
再次讨论p指针转移的意义。如果p指针在某一字符s[m+1]处失配(即p->next[s[m+1]] == NULL)，则说明没有单词s[1...m+1]存在。此时，如果p的失配指针指向root，则说明当前序列的任意后缀不会是某个单词的前缀。如果p的失配指针不指向root，则说明序列s[i...m]是某一单词的前缀，于是跳转到p的失配指针，以s[i...m]为前缀继续匹配s[m+1]。
对于已经得到的序列s[1...m]，由于s[i...m]可能是某单词的后缀，s[1...j]可能是某单词的前缀，所以s[1...m]中可能会出现单词。此时，p指向已匹配的字符，不能动。于是，令temp = p，然后依次测试s[1...m], s[i...m]是否是单词。
构造的Trie为：

**二、构造失败指针**
用BFS来构造失败指针，与KMP算法相似的思想。
首先，root入队，第1次循环时处理与root相连的字符，也就是各个单词的第一个字符h和s，因为第一个字符不匹配需要重新匹配，所以第一个字符都指向root（root是Trie入口，没有实际含义）失败指针的指向对应下图中的(1)，(2)两条虚线；第2次进入循环后，从队列中先弹出h，接下来p指向h节点的fail指针指向的节点，也就是root；p=p->fail也就是p=NULL说明匹配序列为空，则把节点e的fail指针指向root表示没有匹配序列，对应图-2中的(3)，然后节点e进入队列；第3次循环时，弹出的第一个节点a的操作与上一步操作的节点e相同，把a的fail指针指向root，对应图-2中的(4)，并入队；第4次进入循环时，弹出节点h(图中左边那个)，这时操作略有不同。由于p->next[i]!=NULL(root有h这个儿子节点，图中右边那个)，这样便把左边那个h节点的失败指针指向右边那个root的儿子节点h，对应图-2中的(5)，然后h入队。以此类推：在循环结束后，所有的失败指针就是图-2中的这种形式。

**三、扫描**
构造好Trie和失败指针后，我们就可以对主串进行扫描了。这个过程和KMP算法很类似，但是也有一定的区别，主要是因为AC自动机处理的是多串模式，需要防止遗漏某个单词，所以引入temp指针。
匹配过程分两种情况：(1)当前字符匹配，表示从当前节点沿着树边有一条路径可以到达目标字符，此时只需沿该路径走向下一个节点继续匹配即可，目标字符串指针移向下个字符继续匹配；(2)当前字符不匹配，则去当前节点失败指针所指向的字符继续匹配，匹配过程随着指针指向root结束。重复这2个过程中的任意一个，直到模式串走到结尾为止。
 对照上图，看一下模式匹配这个详细的流程，其中模式串为yasherhs。对于i=0,1。Trie中没有对应的路径，故不做任何操作；i=2,3,4时，指针p走到左下节点e。因为节点e的count信息为1，所以cnt+1，并且讲节点e的count值设置为-1，表示改单词已经出现过了，防止重复计数，最后temp指向e节点的失败指针所指向的节点继续查找，以此类推，最后temp指向root，退出while循环，这个过程中count增加了2。表示找到了2个单词she和he。当i=5时，程序进入第5行，p指向其失败指针的节点，也就是右边那个e节点，随后在第6行指向r节点，r节点的count值为1，从而count+1，循环直到temp指向root为止。最后i=6,7时，找不到任何匹配，匹配过程结束。
题目大意：给你很多个单词，然后给你一篇文章，问给出的单词在文章中出现的次数。

``` cpp
#include <iostream>  
#include <string.h>  
#include <stdio.h>  
#include <queue>   
  
using namespace std;  
  
const int N=500010;  
  
char S[1000010];  
char keyword[51];  
  
class Trie  
{  
    public:  
        int count;  
        Trie *fail;  
        Trie *next[26];  
        Trie()  
        {  
            count=0;  
            fail=NULL;  
            memset(next,NULL,sizeof(next));  
        }  
};  
  
Trie *root;  
  
queue<Trie*> Q;  
  
void Insert(char *S)  
{  
    int len=strlen(S);  
    Trie *p=root;  
    for(int i=0; i<len; i++)  
    {  
        int id=S[i]-'a';  
        if(p->next[id]==NULL)  
            p->next[id]=new Trie();  
        p=p->next[id];  
    }  
    p->count++;  
}  
  
void Build_AC()  
{  
    Q.push(root);  
    root->fail=NULL;  
    while(!Q.empty())  
    {  
        Trie *p=NULL;  
        Trie *tmp=Q.front();  
        Q.pop();  
        for(int i=0; i<26; i++)  
        {  
            if(tmp->next[i])  
            {  
                if(tmp==root) tmp->next[i]->fail=root;  
                else  
                {  
                    p=tmp->fail;  
                    while(p)  
                    {  
                        if(p->next[i])  
                        {  
                            tmp->next[i]->fail=p->next[i];  
                            break;  
                        }  
                        p=p->fail;  
                    }  
                    if(p==NULL) tmp->next[i]->fail=root;  
                }  
                Q.push(tmp->next[i]);  
            }  
        }  
    }  
}  
  
int Query()  
{  
    Trie *p=root;  
    int index,result=0;  
    int len=strlen(S);  
    for(int i=0; i<len; i++)  
    {  
        index=S[i]-'a';  
        while(p->next[index]==NULL&&p!=root) p=p->fail;  
        p=p->next[index];  
        if(p==NULL) p=root;  
        Trie *temp=p;  
        while(temp!=root&&temp->count!=-1)  
        {  
            result+=temp->count;  
            temp->count=-1;  
            temp=temp->fail;  
        }  
    }  
    return result;  
}  
  
int main()  
{  
    int t,n;  
    scanf("%d",&t);  
    while(t--)  
    {  
        root=new Trie();  
        scanf("%d",&n);  
        getchar();  
        while(n--)  
        {  
            gets(keyword);  
            Insert(keyword);  
        }  
        Build_AC();  
        scanf("%s",S);  
        printf("%d\n",Query());  
    }  
    return 0;  
}  
```
封装类的AC自动机：

``` cpp
#include<cstdio>  
#include<cstring>  
#include<queue>  
using namespace std;  
const int maxnode=11000;  
const int sigma_size=26;  
struct AC_Automata  
{  
    int ch[maxnode][sigma_size];  
    int val[maxnode];   // 每个字符串的结尾结点都有一个非0的val  
    int f[maxnode];     // fail函数  
    int last[maxnode];  // last[i]=j表j节点表示的单词是i节点单词的后缀，且j节点是单词节点  
    int sz;  
  
    //初始化0号根节点的相关信息  
    void init()  
    {  
        sz=1;  
        memset(ch[0],0,sizeof(ch[0]));  
        val[0]=0;  
    }  
  
    //insert负责构造ch与val数组  
    //插入字符串,v必须非0表示一个单词节点  
    void insert(char *s,int v)  
    {  
        int n=strlen(s),u=0;  
        for(int i=0; i<n; i++)  
        {  
            int id=s[i]-'a';  
            if(ch[u][id]==0)  
            {  
                ch[u][id]=sz;  
                memset(ch[sz],0,sizeof(ch[sz]));  
                val[sz++]=0;  
            }  
            u=ch[u][id];  
        }  
        val[u]=v;  
    }  
  
    //getFail函数负责构造f和last数组  
    void getFail()  
    {  
        queue<int> q;  
        last[0]=f[0]=0;  
        for(int i=0; i<sigma_size; i++)  
        {  
            int u=ch[0][i];  
            if(u)  
            {  
                f[u]=last[u]=0;  
                q.push(u);  
            }  
        }  
  
        while(!q.empty())// 按BFS顺序计算fail  
        {  
            int r=q.front(); q.pop();  
            for(int i=0; i<sigma_size; i++)  
            {  
                int u=ch[r][i];  
                if(u==0)continue;  
                q.push(u);  
  
                int v=f[r];  
                while(v && ch[v][i]==0) v=f[v];  
                f[u]= ch[v][i];  
                last[u] =  val[f[u]]?f[u]:last[f[u]];  
            }  
        }  
    }  
  
    //递归打印与结点i后缀相同的前缀节点编号  
    //进入此函数前需保证val[i]>0  
    void print(int i)  
    {  
        if(i)  
        {  
            printf("%d\n",i);  
            print(last[i]);  
        }  
    }  
  
    // 在s中找出 出现了哪几个模板单词  
    void find(char *s)  
    {  
        int n=strlen(s),j=0;  
        for(int i=0; i<n; i++)  
        {  
            int id=s[i]-'a';  
            while(j && ch[j][id]==0) j=f[j];  
            j=ch[j][id];  
            if(val[j]) print(j);  
            else if(last[j]) print(last[j]);  
        }  
    }  
  
};  
AC_Automata ac;  
```


### 扩展KMP算法
扩展KMP的应用：
 给出模板串S和串T，长度分别为Slen和Tlen，要求在线性时间内，对于每个`S[i]（0<=i<Slen)`，求出S[i..Slen-1]与T的最长公共前缀长度，记为extend[i]（或者说，extend[i]为满足S[i..i+z-1]==T[0..z-1]的最大的z值）。
扩展KMP可以用来解决很多字符串问题，如求一个字符串的最长回文子串和最长重复子串。
 
题意：给一个数字，每一次把它的最后一位拿到最前面，一直那样下去，分别求形成的数字小于，等于和大于原来数的个数。
例如：134可以形成134，341，413三个数，所以分别是1，1，1。
 
分析：
由于长度为len的字符串形成题目要求的串的个数为len，那么我们可以把原来的两个串T连接起来形成字符串S，然后找S的每个后缀的前len个元素即可。这里主要是如何比较的问题，对于字符串的比较，我们可以先求出他们的最长公共前缀长度，然后只需要比较一次就可以知道结果了。那么最长公共前缀怎么求，由于这里是一个串T与另一个串S，来求S的所有后缀与T的最长公共前缀长度，所以用扩展
KMP。如果extend[i]>=len，就说明与原来的相等了，否则如果`S[i+extend[i]]<T[extend[i]]`就说明小于，否则就是大
于。

``` cpp
#include <stdio.h>  
#include <string.h>  
#define N 500010  
  
int next[N];  
int nextval[N];  
int extend[N];  
  
char S[N];  
char T[N];  
  
void GetNext(char *T)  
{  
    int a=0;  
    int Tlen=strlen(T);  
    next[0]=Tlen;  
    while(a<Tlen-1&&T[a]==T[a+1]) a++;  
    next[1]=a;  
    a=1;  
    for(int k=2;k<Tlen;k++)  
    {  
        int p=a+next[a]-1,L=next[k-a];  
        if((k-1)+L>=p)  
        {  
            int j=(p-k+1)>0? p-k+1:0;  
            while(k+j<Tlen&&T[k+j]==T[j]) j++;  
            next[k]=j;  
            a=k;  
        }  
        else next[k]=L;  
    }  
}  
  
void GetExtend(char *S,char *T)  
{  
    int a=0;  
    GetNext(T);  
    int Slen=strlen(S);  
    int Tlen=strlen(T);  
    int MinLen=Slen<Tlen? Slen:Tlen;  
    while(a<MinLen&&S[a]==T[a]) a++;  
    extend[0]=a;  
    a=0;  
    for(int k=1;k<Slen;k++)  
    {  
        int p=a+extend[a]-1,L=next[k-a];  
        if((k-1)+L>=p)  
        {  
            int j=(p-k+1)>0? p-k+1:0;  
            while(k+j<Slen&&j<Tlen&&S[k+j]==T[j]) j++;  
            extend[k]=j;  
            a=k;  
        }  
        else extend[k]=L;  
    }  
}  
  
void NextVal(char *T)  
{  
    int i=0,j=-1;  
    nextval[0]=-1;  
    int Tlen=strlen(T);  
    while(i<Tlen)  
    {  
        if(j==-1||T[i]==T[j])  
        {  
            i++;  
            j++;  
            if(T[i]!=T[j]) nextval[i]=j;  
            else  nextval[i]=nextval[j];  
        }  
        else j=nextval[j];  
    }  
}  
  
int main()  
{  
    int Slen,Tlen,i;  
    int t,tt=1;  
    scanf("%d",&t);  
    while(t--)  
    {  
        scanf("%s",S);  
        strcpy(T,S);  
        strcat(S,T);  
        GetExtend(S,T);  
        Tlen=strlen(T);  
        Slen=strlen(S);  
        NextVal(T);  
        int MOD=Tlen-nextval[Tlen];  
        int temp=1;  
        if(Tlen%MOD==0) temp=Tlen/MOD;  
        int ans1=0,ans2=0,ans3=0;  
        for(i=0;i<Tlen;i++)  
        {  
            if(extend[i]>=Tlen) ans2++;  
            else if(S[i+extend[i]]<T[extend[i]]) ans1++;  
            else ans3++;  
        }  
        printf("Case %d: %d %d %d\n",tt++,ans1/temp,ans2/temp,ans3/temp);  
    }  
    return 0;  
}  
```

### KMP字符串匹配
**next数组的意义：** 
当一个字符串以0为起始下标时，next[i]可以描述为"不为自身的最大首尾重复子串长度"。
也就是说，从模式串T[0...i-1]的第一个字符开始截取一段长度为m(m < i-1)子串，再截取模式串T[0...i-1]的最后m个
字符作为子串，如果这两个子串相等，则该串就是一个首尾重复子串。我们的目的就是要找出这个最大的m值。
 
 
**next数组的应用：**
POJ2406，给一个长度为1000000的字符串，求它由多少个最小的循环节组成，例如：ababab，它由3个ab组成，所以答案是3，再比如abcdabcdab，它只能由一个abcdabcdab组成，所以答案是1.
 
关于最小的循环节，有一个重要的性质：tmp = len-next[len]为字符串str的最小循环节，且有：IF len MOD tmp == 0 最小循环周期 ans = len MOD tmp;ELSE 最小循环周期ans = 1;
 
注意在求循环节问题时的next数组不要优化，在做匹配时才优化。
 那么POJ1961就很好做了，也是一样的求最小循环周期，题意是给一个长度为1000000的字符串，然后求它所有前缀的不为1的最小循环周期。POJ2752，题意：给一个字符串S，输出该字符串中既是前缀又是后缀的所有子串的长度，按照从小到大输出。当然，我们用KMP可以这样做，先求next数组，然后next[len]就是除了S本身外满足条件的最长子串长度，然后我们按照它的next数组往前跳就找到所有的了。

``` cpp
void GetNext(char *T)  
{  
    int i=0,j=-1;  
    next[0]=-1;  
    int Tlen=strlen(T);  
    while(i<Tlen)  
    {  
        if(j==-1||T[i]==T[j])  
        {  
            i++; j++;  
            if(T[i]!=T[j])  
                next[i]=j;  
            else  
                next[i]=next[j];  
        }  
        else j=next[j];  
    }  
}  
  
bool KMP(char *S,char *T)  
{  
    int i=0,j=0;  
    GetNext(T);  
    int Slen=strlen(S);  
    int Tlen=strlen(T);  
    while(i<Slen&&j<Tlen)  
    {  
        if(j==-1||S[i]==T[j])  
        {  
            i++;  
            j++;  
        }  
        else  
        {  
            j=next[j];  
        }  
    }  
    if(j>=Tlen) return true;  
    else return false;  
}  
```
MP与KMP模板：

``` cpp
/*************************MP模板****************************/  
char T[1000];//待匹配串  
char P[100];//模板串  
  
//失配指针,记住这里f要比P多一位  
//因为P到m-1即可,但是f还要计算出m的失配指针  
int f[101];  
  
void find(char *T, char *P, int *f) //找到所有匹配点  
{  
    int n = strlen(T);  
    int m = strlen(P);  
    int j = 0;  
    for(int i = 0; i < n; i++)  
    {  
        while(j && T[i] != P[j]) j = f[j];  
        if(T[i] == P[j]) j++;  
        if(j == m) printf("%d\n", i - m + 1);//就算j到m了，也用f[m]继续匹配  
    }  
}  
void getFail(char *P, int *f)  
{  
    int m = strlen(P);  
    f[0] = f[1] = 0;  
    for(int i = 1; i < m; i++)//虽然字符串是0到m-1，但是要求出f[m]的值  
    {  
        int j = f[i];  
        while(j && P[i] != P[j]) j = f[j];  
        f[i + 1] = P[i] == P[j] ? j + 1 : 0;  
    }  
}  
/*************************MP模板****************************/  
  
  
/*************************KMP模板****************************/  
char T[1000];//待匹配串  
char P[100];//模板串  
int f[101];//优化后的失配指针,记住这里f要比P多一位,因为P到m-1即可,但是f还要计算出m的失配指针  
int f2[101];//f2用来保存KM指针，是为优化f的失配指针,f保存的是优化之后的失配指针  
void find(char *T, char *P, int *f) //找到所有匹配点  
{  
    int n = strlen(T);  
    int m = strlen(P);  
    int j = 0;  
    for(int i = 0; i < n; i++)  
    {  
        while(j && T[i] != P[j]) j = f[j];  
        if(T[i] == P[j]) j++;  
        if(j == m) printf("%d\n", i - m + 1);  
    }  
}  
void getFail(char *P, int *f)  
{  
    int m = strlen(P);  
    f[0] = f[1] = 0;  
    f2[0]=f2[1]=0;  
    for(int i = 1; i < m; i++)  
    {  
        int j = f2[i];  
        while(j && P[i] != P[j] ) j = f2[j];  
        f2[i+1] = f[i + 1] = (P[i] == P[j]) ? j + 1 : 0;  
  
        //既然i+1的失配位置指向j+1，但是P[i+1]和P[j+1]的内容是相同的  
        //所以就算指针从i+1跳到j+1去，还是不能匹配，所以f[i+1]直接=f[j+1]  
        if(f[i+1]==j+1 && P[i+1]==P[j+1]) f[i+1]=f[j+1];  
    }  
}  
/*************************KMP模板****************************/  
```

### 树状数组
对于一个n元素的数组A[n]，可执行如下操作：
Add(I, d)：让A[i]变成A[i]+d。
Query(L, R)：返回A[L]+A[L+1]+…+A[R]。
注意：树状数组只能计算A[1]开始的和，A[0]这个元素是不能用的。上面操作复杂度都是O(logn)。
其实树状数组还可以处理区间更新，单点查询的问题。如HDU 1556 Color the ball，但是此类问题还是用线段树做比较直观。

``` cpp
const int maxn=10000+5;//最大元素个数  
  
int n;//元素个数  
int c[maxn];//c[i]==A[i]+A[i-1]+...+A[i-lowbit(i)+1]  
  
//返回i的二进制最右边1的值  
int lowbit(int i)  
{  
    return i&(-i);  
}  
  
//返回A[1]+...A[i]的和  
int sum(int i)  
{  
    int res=0;  
    while(i>0)  
    {  
        res += c[i];  
        i -= lowbit(i);  
    }  
    return res;  
}  
  
//令A[i] += val  
void add(int i,int val)  
{  
    while(i<=n)  
    {  
        c[i] += val;  
        i += lowbit(i);  
    }  
}  
```


### Trie树（字典树）

``` cpp
class Trie  
{  
    public:  
       int v;  
       Trie *next[26];  
       Trie()  
       {  
           v=0;  
           memset(next,NULL,sizeof(next));  
       }  
};  
  
Trie *root;  
  
void Insert(char *S)  
{  
    int len=strlen(S);  
    Trie *p=root;  
    for(int i=0;i<len;i++)  
    {  
        int id=S[i]-'a';  
        if(p->next[id]==NULL)  
            p->next[id]=new Trie();  
        p=p->next[id];  
    }  
    p->v++;  
}  
  
int Find(char *S)  //如果找到S串，返回它在字典树中出现次数，否则返回0  
{  
    Trie *p=root;  
    int len=strlen(S);  
    for(int i=0;i<len;i++)  
    {  
        int id=S[i]-'a';  
        p=p->next[id];  
        if(p==NULL) return 0;  
    }  
    return p->v;  
}  
  
int Delete(Trie *T)      //删除整棵字典树  
{  
    if(T==NULL) return 0;  
    for(int i=0;i<26;i++)  
        if(T->next[i]!=NULL)  
            Delete(T->next[i]);  
    delete T;  
    return 0;  
}  
  
root=new Trie();  //main中的初始化  
```

### 字符串哈希处理
字符串Hash无论是在ACM竞赛中还是在工程中都有着广泛的应用，所以很有必要掌握好它的用法。主要分为两个部
分：Hash映射和冲突处理。而本文主要来详细讲解Hash映射的方法及应用，下篇文章将会介绍如何处理冲突。
 
对于字符串Hash来说都是把字符串映射为一个整数，这一步是通过Hash函数来进行的。常用的Hash函数具体有：
SDBMHash，RSHash，JSHash，ELFHash，BKDRHash，DJBHash等等。接下来只详细介绍ELFHash函数的原理
及应用。
 
ELFHash函数的代码如下：

``` cpp
unsigned int ELFhash(char *str)  
{  
    unsigned int h = 0;  
    unsigned int x;  
    while(*str)  
    {  
        h = (h << 4) + *str++;  
        x = h & 0xF0000000L;  
        if(x)  
        {  
            h ^= x>>24;  
            h &= ~x;  
        }  
    }  
    return h & 0x7FFFFFFF;  
}  
```

题意：给定一些数字，可能有前导零，求这些数字中出现次数最多的数字的次数。

``` cpp
#include <iostream>  
#include <string.h>  
#include <stdio.h>  
  
using namespace std;  
const int N = 1000005;  
const int MOD = 100007;  
  
int hash[N], cnt[N];  
  
unsigned int ELFhash(char *str)  
{  
    unsigned int h = 0;  
    unsigned int x;  
    while(*str)  
    {  
        h = (h << 4) + *str++;  
        x = h & 0xF0000000L;  
        if(x)  
        {  
            h ^= x>>24;  
            h &= ~x;  
        }  
    }  
    return h & 0x7FFFFFFF;  
}  
  
int HashHit(char *str)  
{  
    while(*str == '0') str++;  
    int k = ELFhash(str);  
    int t = k % MOD;  
    while(hash[t] != k && hash[t] != -1)  
        t = (t + 10) % MOD;  
    if(hash[t] == -1)  
    {  
        cnt[t] = 1;  
        hash[t] = k;  
    }  
    else cnt[t]++;  
    return cnt[t];  
}  
  
int main()  
{  
    int n;  
    char str[105];  
    while(scanf("%d", &n)!=EOF)  
    {  
        int ans = 1;  
        memset(hash,-1,sizeof(hash));  
        while(n--)  
        {  
            scanf("%s", str);  
            ans = max(ans, HashHit(str));  
        }  
        printf("%d\n", ans);  
    }  
    return 0;  
}  
```
对于Hash，我们是怎样来处理冲突的。现在就来介绍一些经典的Hash冲突处理的方法。主要包括：
 
（1）开放地址法
 基本思想：当发生地址冲突时，按照某种方法继续探测Hash表中其它存储单元，直到找到空位置为止。描述如下 其中，为关键字的直接Hash地址，为Hash表的长度，为每次再探测时的地址增量。
 
（2）拉链法
拉链法又叫链地址法，适合处理冲突比较严重的情况。基本思想是把所有关键字为同义词的记录存储在同一个线性链表中。

``` cpp
#include <iostream>  
#include <string.h>  
#include <stdio.h>  
  
using namespace std;  
const int N = 35;  
  
struct node  
{  
    int key;    //关键字  
    int len;    //每个节点引出的链表长度  
    bool flag;  //有数据的标志  
    node *next;  
};  
  
node list[N];  
  
void Init(node list[])  
{  
    for(int i=0; i<N; i++)  
    {  
        list[i].len = 0;  
        list[i].flag = 0;  
        list[i].next = NULL;  
    }  
}  
  
void Insert(node list[], int val, int m)  
{  
    int id = val % m;  
    if(!list[id].flag)  
    {  
        list[id].key = val;  
        list[id].flag = 1;  
    }  
    else  
    {  
        node *p = new node();  
        p->key = val;  
        p->next = list[id].next;  
        list[id].next = p;  
    }  
}  
  
//输出HashTable  
void Print(node list[], int m)  
{  
    for(int i=0; i<m; i++)  
    {  
        node *p = list[i].next;  
        if(!list[i].flag)  
            printf("The %dth record is NULL!\n", i);  
        else  
        {  
            printf("The %dth record is %d", i, list[i].key);  
            list[i].len++;  
            while(p)  
            {  
                printf("->%d", p->key);  
                p = p->next;  
                list[i].len++;  
            }  
            puts("");  
        }  
    }  
}  
  
//计算平均查找长度  
double ASL(node list[], int m)  
{  
    double ans = 0;  
    for(int i=0; i<m; i++)  
        ans += (list[i].len + 1) * list[i].len / 2.0;  
    return ans / m;  
}  
  
int main()  
{  
    int n, m;  
    Init(list);  
    scanf("%d %d", &n, &m);  
    for(int i=0; i<n; i++)  
    {  
        int val;  
        scanf("%d", &val);  
        Insert(list, val, m);  
    }  
    Print(list, m);  
    printf("The Average Search Length is %.5lf\n", ASL(list, m));  
    return 0;  
}  
  
/** 
12 11 
47 7 29 11 16 92 22 8 3 37 89 50 
*/  
```
（3）再哈希法
再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，....，等哈希函数计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。
 
（4）建立公共溢出区 
建立公共溢出区的基本思想是：假设哈希函数的值域是[1,m-1]，则设向量HashTable[0...m-1]为基本
表，每个分量存放一个记录，另外设向量OverTable[0...v]为溢出表，所有关键字和基本表中关键字为同义
词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。

### 最长公共子串问题(后缀自动机)
题意：给两个串A和B，求这两个串的最长公共子串。
 
分析：其实本题用后缀数组的DC3已经能很好的解决，这里我们来说说利用后缀自动机如何实现。
对于串A和B，我们先构造出串A的后缀自动机，那么然后用B串去匹配，对于B，我们一位一位地扫描，维护一个ans值，表示从B串的开始到B[i]的这个子串与A的最长公共子串。
 
假设现在到B[i-1]的最长公共子串长度为ans，然后我们来看B[i]，如果当前节点有B[i]这个孩子，那么直接就len++即可。如果没有就找一直向前找pre，直到找到有B[i]这个孩子的节点。

``` cpp
#include <iostream>  
#include <string.h>  
#include <algorithm>  
#include <stdio.h>  
  
using namespace std;  
const int N=250005;  
  
struct State  
{  
    State *pre,*go[26];  
    int step;  
    void clear()  
    {  
        pre=0;  
        step=0;  
        memset(go,0,sizeof(go));  
    }  
}*root,*last;  
  
State statePool[N*2],*cur;  
  
void init()  
{  
    cur=statePool;  
    root=last=cur++;  
    root->clear();  
}  
  
void Insert(int w)  
{  
    State *p=last;  
    State *np=cur++;  
    np->clear();  
    np->step=p->step+1;  
    while(p&&!p->go[w])  
        p->go[w]=np,p=p->pre;  
    if(p==0)  
        np->pre=root;  
    else  
    {  
        State *q=p->go[w];  
        if(p->step+1==q->step)  
            np->pre=q;  
        else  
        {  
            State *nq=cur++;  
            nq->clear();  
            memcpy(nq->go,q->go,sizeof(q->go));  
            nq->step=p->step+1;  
            nq->pre=q->pre;  
            q->pre=nq;  
            np->pre=nq;  
            while(p&&p->go[w]==q)  
                p->go[w]=nq, p=p->pre;  
        }  
    }  
    last=np;  
}  
  
char A[N],B[N];  
  
int main()  
{  
    int n,m;  
    scanf("%s%s",A,B);  
    n=strlen(A);  
    m=strlen(B);  
    init();  
    for(int i=0; i<n; i++)  
        Insert(A[i]-'a');  
    int ans=0,len=0;  
    State *p=root;  
    for(int i=0; i<m; i++)  
    {  
        int x=B[i]-'a';  
        if(p->go[x])  
        {  
            len++;  
            p=p->go[x];  
        }  
        else  
        {  
            while(p&&!p->go[x]) p=p->pre;  
            if(!p) p=root,len=0;  
            else   len=p->step+1,p=p->go[x];  
        }  
        ans=max(ans,len);  
    }  
    printf("%d\n",ans);  
    return 0;  
}  
```
### 后缀自动机
题目大意：给一个字符串S和一系列字符串T1~Tn，问在S中有多少个不同子串满足它不是T1~Tn中任意一个字符串的子串。

``` cpp
#include <iostream>  
#include <string.h>  
#include <algorithm>  
#include <stdio.h>  
  
using namespace std;  
typedef long long LL;  
const int N=550005;  
  
struct State  
{  
    State *pre,*go[26];  
    int step,deep;  
    void clear()  
    {  
        pre=0;  
        deep=0;  
        step=0;  
        memset(go,0,sizeof(go));  
    }  
}*root,*last;  
  
State statePool[N*2],*b[2*N],*cur;  
  
void init()  
{  
    cur=statePool;  
    root=last=cur++;  
    root->clear();  
}  
  
void Insert(int w)  
{  
    State *p=last;  
    State *np=cur++;  
    np->clear();  
    np->step=p->step+1;  
    while(p&&!p->go[w])  
        p->go[w]=np,p=p->pre;  
    if(p==0)  
        np->pre=root;  
    else  
    {  
        State *q=p->go[w];  
        if(p->step+1==q->step)  
            np->pre=q;  
        else  
        {  
            State *nq=cur++;  
            nq->clear();  
            memcpy(nq->go,q->go,sizeof(q->go));  
            nq->step=p->step+1;  
            nq->pre=q->pre;  
            q->pre=nq;  
            np->pre=nq;  
            while(p&&p->go[w]==q)  
                p->go[w]=nq, p=p->pre;  
        }  
    }  
    last=np;  
}  
  
char str[N];  
int cnt[N];  
  
void Solve(int Q,int n)  
{  
    memset(cnt,0,sizeof(cnt));  
    for(State *p=statePool; p!=cur; p++)  
        cnt[p->step]++;  
    for(int i=1; i<=n; i++)  
        cnt[i]+=cnt[i-1];  
    for(State *p=statePool; p!=cur; p++)  
        b[--cnt[p->step]]=p;  
    while(Q--)  
    {  
        scanf("%s",str);  
        int len=0;  
        int m=strlen(str);  
        State *p=root;  
        for(int i=0; i<m; i++)  
        {  
            int x=str[i]-'a';  
            if(p->go[x])  
            {  
                len++;  
                p=p->go[x];  
                p->deep=max(p->deep,len);  
            }  
            else  
            {  
                while(p&&!p->go[x]) p=p->pre;  
                if(!p) p=root,len=0;  
                else  
                {  
                    len=p->step+1;  
                    p=p->go[x];  
                    p->deep=max(p->deep,len);  
                }  
            }  
        }  
    }  
    LL sum=0;  
    int num=cur-statePool;  
    for(int i=num-1; i>0; i--)  
    {  
        State *q=b[i];  
        if(q->deep>0)  
        {  
            q->pre->deep=max(q->pre->deep,q->deep);  
            if(q->deep<q->step) sum+=q->step-q->deep;  
        }  
        else sum+=q->step-q->pre->step;  
    }  
    printf("%I64d\n",sum);  
}  
  
int main()  
{  
    int t,k=1,Q;  
    scanf("%d",&t);  
    while(t--)  
    {  
        printf("Case %d: ",k++);  
        scanf("%d",&Q);  
        scanf("%s",str);  
        int n=strlen(str);  
        init();  
        for(int i=0; i<n; i++)  
            Insert(str[i]-'a');  
        Solve(Q,n);  
    }  
    return 0;  
}  


```

### 后缀自动机求n个串的最长公共子串
题意：给定n个串，求它们的最长公共子串。
 
思路就是：先将一个串建SAM，然后用后面的串去匹配，对于每一个串，保存最大值，对于不同的串，更新最小值。
SAM结点多两个值，ml表示多个串的最小值，nl表示当前串匹配的最大值。

``` cpp
#include <iostream>  
#include <string.h>  
#include <algorithm>  
#include <stdio.h>  
  
using namespace std;  
const int N=250005;  
  
struct State  
{  
    State *pre,*go[26];  
    int step,nl,ml;  
    void clear()  
    {  
        pre=0;  
        step=0;  
        memset(go,0,sizeof(go));  
    }  
}*root,*last;  
  
State statePool[N*2],*b[2*N],*cur;  
  
void init()  
{  
    cur=statePool;  
    root=last=cur++;  
    root->clear();  
}  
  
void Insert(int w)  
{  
    State *p=last;  
    State *np=cur++;  
    np->clear();  
    np->step=np->ml=p->step+1;  
    while(p&&!p->go[w])  
        p->go[w]=np,p=p->pre;  
    if(p==0)  
        np->pre=root;  
    else  
    {  
        State *q=p->go[w];  
        if(p->step+1==q->step)  
            np->pre=q;  
        else  
        {  
            State *nq=cur++;  
            nq->clear();  
            memcpy(nq->go,q->go,sizeof(q->go));  
            nq->step=nq->ml=p->step+1;  
            nq->pre=q->pre;  
            q->pre=nq;  
            np->pre=nq;  
            while(p&&p->go[w]==q)  
                p->go[w]=nq, p=p->pre;  
        }  
    }  
    last=np;  
}  
  
char str[N];  
int cnt[N];  
  
int main()  
{  
    int n,m;  
    scanf("%s",str);  
    n=strlen(str);  
    init();  
    for(int i=0; i<n; i++)  
        Insert(str[i]-'a');  
    for(State *p=statePool; p!=cur; p++)  
        cnt[p->step]++;  
    for(int i=1; i<=n; i++)  
        cnt[i]+=cnt[i-1];  
    for(State *p=statePool; p!=cur; p++)  
        b[--cnt[p->step]]=p;  
    while(~scanf("%s",str))  
    {  
        int len=0;  
        m=strlen(str);  
        State *p=root;  
        for(int i=0; i<m; i++)  
        {  
            int x=str[i]-'a';  
            if(p->go[x])  
            {  
                len++;  
                p=p->go[x];  
            }  
            else  
            {  
                while(p&&!p->go[x]) p=p->pre;  
                if(!p) p=root,len=0;  
                else   len=p->step+1,p=p->go[x];  
            }  
            if(len>p->nl) p->nl=len;  
        }  
        int num=cur-statePool;  
        for(int i=num-1;i>=0;i--)  
        {  
            p=b[i];  
            if(p->ml>p->nl) p->ml=p->nl;  
            if(p->pre&&p->pre->nl<p->nl) p->pre->nl=p->nl;  
            p->nl=0;  
        }  
    }  
    int ans=0;  
    for(State *p=statePool;p!=cur;p++)  
        if(p->ml>ans) ans=p->ml;  
    printf("%d\n",ans);  
    return 0;  
}  


```

### 后缀自动机--第k大的子串
题意：给一个字符串，然后给Q个询问，每个询问输入一个数K，输出子串中字典序为K的字符串。

``` cpp
#include <iostream>  
#include <string.h>  
#include <algorithm>  
#include <stdio.h>  
  
using namespace std;  
const int N=250005;  
  
struct State  
{  
    State *pre,*go[26];  
    int step,v;  
    void clear()  
    {  
        v=0;  
        pre=0;  
        step=0;  
        memset(go,0,sizeof(go));  
    }  
}*root,*last;  
  
State statePool[N*2],*b[2*N],*cur;  
  
void init()  
{  
    cur=statePool;  
    root=last=cur++;  
    root->clear();  
}  
  
void Insert(int w)  
{  
    State *p=last;  
    State *np=cur++;  
    np->clear();  
    np->step=p->step+1;  
    while(p&&!p->go[w])  
        p->go[w]=np,p=p->pre;  
    if(p==0)  
        np->pre=root;  
    else  
    {  
        State *q=p->go[w];  
        if(p->step+1==q->step)  
            np->pre=q;  
        else  
        {  
            State *nq=cur++;  
            nq->clear();  
            memcpy(nq->go,q->go,sizeof(q->go));  
            nq->step=p->step+1;  
            nq->pre=q->pre;  
            q->pre=nq;  
            np->pre=nq;  
            while(p&&p->go[w]==q)  
                p->go[w]=nq, p=p->pre;  
        }  
    }  
    last=np;  
}  
  
char str[N];  
int son[2*N][26];  
char ch[2*N][26];  
int cnt[2*N],c[2*N];  
  
void Solve(int k)  
{  
    int ct=0;  
    int now=0;  
    while(k)  
    {  
        for(int i=0; i<c[now]; i++)  
        {  
            State *tmp=statePool+son[now][i];  
            if(k>tmp->v)  
                k-=tmp->v;  
            else  
            {  
                str[ct++]=ch[now][i];  
                now=son[now][i];  
                k--;  
                break;  
            }  
        }  
    }  
    str[ct]=0;  
    puts(str);  
}  
  
int main()  
{  
    int n;  
    scanf("%s",str);  
    n=strlen(str);  
    init();  
    for(int i=0; i<n; i++)  
        Insert(str[i]-'a');  
    memset(cnt,0,sizeof(cnt));  
    memset(c,0,sizeof(c));  
    for(State *p=statePool; p!=cur; p++)  
        cnt[p->step]++;  
    for(int i=1; i<cur-statePool; i++)  
        cnt[i]+=cnt[i-1];  
    for(State *p=statePool; p!=cur; p++)  
        b[--cnt[p->step]]=p;  
    for(State *p=statePool; p!=cur; p++)  
        p->v=1;  
  
    int num=cur-statePool;  
    for(int i=num-1; i>=0; i--)  
    {  
        State *p=b[i];  
        for(int j=0; j<26; j++)  
        {  
            if(p->go[j])  
            {  
                int x=p-statePool;  
                int y=p->go[j]-statePool;  
                son[x][c[x]]=y;  
                ch[x][c[x]++]=j+'a';  
                p->v+=p->go[j]->v;  
            }  
        }  
    }  
    int Q,k;  
    scanf("%d",&Q);  
    while(Q--)  
    {  
        scanf("%d",&k);  
        Solve(k);  
    }  
    return 0;  
}  

```

### Treap树
Treap是一种动态平衡的BST(Binary Search Tree)，它每个节点拥有键值和优先级两种属性。对于键值而言，它是一颗排序二叉树。对于优先级而言，这棵树是堆(优先级最高的是根节点)。可以证明Treap中插入，删除和查找的期望时间复杂度均为O(logn)。关于Treap的更多介绍，可见刘汝佳《训练指南》P230。
一般我们用Treap就是用来替代平衡二叉排序树用的。Treap实现的代码很少，实现简单。我们可以在Treap的基础上实现名次树。

名次树支持两个操作：
1)找出第k小的元素(元素从小到大排序的第k个)。
2)找到值x的名次。

基本代码：
``` cpp
#include<cstdio>  
#include<cstring>  
#include<cstdlib>  
using namespace std;  
  
struct Node  
{  
    Node *ch[2];  
    int r;//优先级,构成大顶堆  
    int v;//键值,构成排序二叉树  
  
    int cmp(int x)//比较键值大小  
    {  
        if(x==v) return -1;  
        return x<v?0:1;  
    }  
};  
  
//d=0表示左旋,d=1表示右旋  
void rotate(Node* &o,int d)  
{  
    Node *k=o->ch[d^1];  
    o->ch[d^1]=k->ch[d];  
    k->ch[d]=o;  
    o=k;  
}  
  
//插入值为x的节点  
void insert(Node* &o,int x)  
{  
    if(o==NULL)  
    {  
        o=new Node();  
        o->ch[0]=o->ch[1]=NULL;  
        o->v=x;  
        o->r=rand();//在cstdlib头声明  
    }  
    else  
    {  
        //如这里改成int d=o->cmp(x);  
        //就不可以插入相同的值，因为d可能为-1  
        int d=x<(o->v)?0:1;  
        insert(o->ch[d],x);  
        if(o->ch[d]->r > o->r)  
            rotate(o,d^1);  
    }  
}  
  
//删除v值为x的节点  
void remove(Node *&o,int v)  
{  
    if(o==NULL) return ;//空时返回  
  
    int d=o->cmp(v);  
    if(d==-1)//o就是需要删除的节点  
    {  
        Node *u=o;  
        if(o->ch[0] && o->ch[1])  
        {  
            int d2 = o->ch[0]->r < o->ch[1]->r ?0:1;  
            rotate(o,d2);  
            remove(o->ch[d2],v);  
        }  
        else  
        {  
            if(o->ch[0]==NULL)o=o->ch[1];  
            else o=o->ch[0];  
            delete u;//记得删除节点  
        }  
    }  
    else remove(o->ch[d],v);  
}  
int find(Node *o,int x)  
{  
    while(o)  
    {  
        int d=o->cmp(x);  
        if(d==-1)return 1; //存在  
        o=o->ch[d];  
    }  
    return 0;              //不存在  
}  
```
名次树：

``` cpp
#include<cstdio>  
#include<cstring>  
#include<cstdlib>  
#include<cassert>  
using namespace std;  
struct Node  
{  
    Node *ch[2];  
    int r,v,s;//s表示节点数  
  
    Node(int v):v(v)  
    {  
        ch[0]=ch[1]=NULL;  
        r=rand();//在cstdlib头声明  
        s=1;  
    }  
  
    int cmp(int x)  
    {  
        if(x==v)return -1;  
        return x<v?0:1;  
    }  
    void maintain()  
    {  
        s=1;  
        if(ch[0]!=NULL) s+=ch[0]->s;  
        if(ch[1]!=NULL) s+=ch[1]->s;  
    }  
};  
void rotate(Node* &o,int d)  
{  
    Node *k=o->ch[d^1];  
    o->ch[d^1]=k->ch[d];  
    k->ch[d]=o;  
    o->maintain();  
    k->maintain();  
    o=k;  
}  
void insert(Node* &o,int x)//o子树中事先不存在x  
{  
    if(o==NULL) o=new Node(x);  
    else  
    {  
        //如这里改成int d=o->cmp(x);  
        //就不可以插入相同的值，因为d可能为-1  
        int d=x<(o->v)?0:1;  
        insert(o->ch[d],x);  
        if(o->ch[d]->r > o->r)  
            rotate(o,d^1);  
    }  
    o->maintain();  
}  
  
void remove(Node* &o,int x)  
{  
    if(o==NULL) return ;//空时返回  
  
    int d=o->cmp(x);  
    if(d==-1)  
    {  
        Node *u=o;  
        if(o->ch[0] && o->ch[1])  
        {  
            int d2=(o->ch[0]->r < o->ch[1]->r)?0:1;  
            rotate(o,d2);  
            remove(o->ch[d2],x);  
        }  
        else  
        {  
            if(o->ch[0]==NULL) o=o->ch[1];  
            else o=o->ch[0];  
            delete u;//这个要放里面  
        }  
    }  
    else remove(o->ch[d],x);  
    if(o) o->maintain();//之前o存在,但是删除节点后o可能就是空NULL了,所以需要先判断o是否为空  
}  
  
//返回关键字从小到大排序时的第k个值  
int kth(Node* o,int k)  
{  
    assert(o && k>=1 && k<=o->s);//保证输入合法  
    int s=(o->ch[0]==NULL)?0:o->ch[0]->s;  
    if(k==s+1) return o->v;  
    else if(k<=s) return kth(o->ch[0],k);  
    else return kth(o->ch[1],k-s-1);  
}  
  
//返回值x在树中的排名,就算x不在o树中也能返回排名  
//返回值范围在[1,o->s+1]范围内  
int rank(Node* o,int x)  
{  
    if(o==NULL) return 1;//未找到x;  
  
    int num= o->ch[0]==NULL ? 0:o->ch[0]->s;  
    if(x==o->v) return num+1;  
    else if(x < o->v) return rank(o->ch[0],x);  
    else return rank(o->ch[1],x)+num+1;  
}  
  
  
int main()  
{  
    int n=0;  
    while(scanf("%d",&n)==1 && n)  
    {  
        Node *root=NULL;  
        for(int i=0;i<n;i++)  
        {  
            int x;  
            scanf("%d",&x);  
            if(root==NULL) root=new Node(x);  
            else insert(root,x);  
        }  
  
        int v;  
        while(scanf("%d",&v)==1)  
        {  
            printf("%d\n",rank(root,v));  
        }  
    }  
    return 0;  
}  
```

### 基于哈希值的LCP算法
题意:给你一个字符串s和m,求出字符串中至少出现m次的最长子串.如果有多解,输出最长字符串的长度以及它出现的最大位置.

``` cpp
#include<iostream>  
#include<cstdio>  
#include<cstring>  
#include<algorithm>  
using namespace std;  
const int maxn = 40000+1000;  
typedef unsigned long long LL;  
LL h[maxn],x;//后缀哈希值  
char str[maxn];  
int n,m,max_pos;  
LL mi[maxn];//mi[i]的值是x的i次方的值  
struct node  
{  
    LL hash;//起点为pos且长len的串的哈希值  
    int pos;//起点位置  
    bool operator <(const node &b)const  
    {  
        return hash<b.hash ||(hash==b.hash && pos<b.pos);  
    }  
}nodes[maxn];  
bool check(int len)  
{  
    for(int i=0;i+len-1<=n-1;i++)//共有n-len+1个长为len的连续子串  
    {  
        nodes[i].hash=h[i]-h[i+len]*mi[len];  
        nodes[i].pos=i;//起点位置  
    }  
    sort(nodes,nodes+n-len+1);  
  
    max_pos=-1;  
    int sum=0;  
    for(int i=0;i+len-1<=n-1;i++)  
    {  
        if(i==0 || nodes[i].hash==nodes[i-1].hash)  
        {  
            sum++;  
            if(sum>=m) max_pos=max(max_pos,nodes[i].pos);  
        }  
        else sum=1;  
    }  
    return max_pos>=0;  
}  
int main()  
{  
    x=123;  
    while(scanf("%d",&m)==1&&m)  
    {  
        scanf("%s",str);  
        n=strlen(str);  
        h[n]=0;  
        for(int i=n-1;i>=0;i--)  
            h[i]=h[i+1]*x+str[i]-'a';  
        mi[0]=1;  
        for(int i=1;i<=n;i++)  
            mi[i]=mi[i-1]*x;  
        if(!check(1))  
        {  
            printf("none\n");  
            continue;  
        }  
        int min=1,max=n;  
        while(min<max)  
        {  
            int mid=min+(max-min+1)/2;  
            if(check(mid)) min=mid;  
            else max=mid-1;  
        }  
        check(min);  
        printf("%d %d\n",min,max_pos);  
    }  
    return 0;  
}  
```

### 连续自然数的lcm
题意：给定一个正整数n，lcm（1-n）求的值，输入数据有10000组，每组一个数n，1<=n<=10^8。

``` cpp
#include <iostream>  
#include <string.h>  
#include <algorithm>  
#include <stdio.h>  
#include <math.h>  
  
using namespace std;  
typedef unsigned int uint;  
const int N = 100000005;  
const int M = 6000005;  
const int SHIFT = 5;  
const int RADIX = (1 << SHIFT) - 1;  
  
int flag[(N>>SHIFT)+1];  
uint sum[M];  
int p[M];  
int k;  
  
inline void SetBit(int x)  
{  
    flag[x>>SHIFT] |= (1<<(x&RADIX));  
}  
  
inline bool GetBit(int x)  
{  
    return flag[x>>SHIFT] & (1<<(x&RADIX));  
}  
  
void isprime()  
{  
    k = 0;  
    for(int i=2; i<N; i++)  
    {  
        if(!GetBit(i))  
        {  
            p[k++] = i;  
            for(int j=i+i; j<N; j+=i)  
                SetBit(j);  
        }  
    }  
}  
  
void Init()  
{  
    sum[0] = p[0];  
    for(int i=1; i<k; i++)  
        sum[i] = sum[i-1] * p[i];  
}  
  
int main()  
{  
    isprime();  
    Init();  
    int T,n,tt = 1;  
    scanf("%d",&T);  
    while(T--)  
    {  
        scanf("%d",&n);  
        printf("Case %d: ",tt++);  
        uint ans = 1;  
        int cnt = 1;  
        while(1)  
        {  
            int m = (int)pow(n+0.9,1.0/cnt);  
            if(m < 2) break;  
            int i = lower_bound(p,p+k,m) - p;  
            if(p[i] != m) i--;  
            ans *= sum[i];  
            cnt++;  
        }  
        printf("%u\n",ans);  
    }  
    return 0;  
}  
```

### 积性函数

``` cpp
#include <iostream>  
#include <string.h>  
#include <stdio.h>  
  
using namespace std;  
typedef long long LL;  
const int N = 10000005;  
const int M = 1000005;  
  
bool prime[N];  
int p[N];  
int k;  
  
void isprime()  
{  
    k = 0;  
    memset(prime,true,sizeof(prime));  
    for(int i=2;i<N;i++)  
    {  
        if(prime[i])  
        {  
            p[k++] = i;  
            for(int j=i+i;j<N;j+=i)  
                prime[j] = false;  
        }  
    }  
}  
  
LL quick_mod(LL a,LL b,LL m)  
{  
    LL ans = 1;  
    a %= m;  
    while(b)  
    {  
        if(b&1)  
        {  
            ans = ans * a % m;  
            b--;  
        }  
        b >>= 1;  
        a = a * a % m;  
    }  
    return ans;  
}  
  
int main()  
{  
    int n,m,t;  
    isprime();  
    scanf("%d",&t);  
    while(t--)  
    {  
        scanf("%d%d",&n,&m);  
        LL cnt = 0;  
        for(int i=0;i < k;i++)  
        {  
            if(p[i] > n) break;  
            cnt += n / p[i];  
        }  
        LL ans = quick_mod(2,cnt,m);  
        printf("%I64d\n",ans);  
    }  
    return 0;  
}  
```

### 莫比乌斯反演
题意：给出n, m, p，求有多少对a, b满足gcd(a, b)的素因子个数<=p，(其中1<=a<=n, 1<=b<=m)
分析：设A(d)：gcd(a, b)=d的有多少种
     设B(j): gcd(a, b)是j的倍数的有多少种，易知B(j) = (n/j)*(m/j)
     则由容斥原理得：（注：不同行的μ是不相同的，μ为莫比乌斯函数）
     A(1) = μ(1)*B(1) + μ(2)*B(2) + μ(3)*B(3) + ... + μ(p1*p2...)*B(p1*p2...)
     A(2) = μ(1)*B(1*2) + μ(2)*B(2*2) + μ(3)*B(3*2) + ... + μ(p1*p2..)*B(p1*p2..*2)
     ...
     A(d) = μ(1)*B(1*d) + μ(2)*B(2*d) + μ(3)*B(3*d) + ... + μ(p1*p2..)*B(p1*p2..*d)
 
   ans = A(1)+A(2)+...+A(d) = F(1)*B(1) + F(2)*B(2) + ... + F(p1*p2..)*B(p1*p2..)

   于是可以枚举公约数i{表示A(i)}，利用筛法找出i的倍数j，i对B(j)的贡献系数为：F(j)+=μ(j/i)
     总之，求出B(j)的总贡献系数F(j)即可得答案：F(1)*B(1)+F(2)*B(2)+...+F(n)*B(n)
     上面没有限制gcd的素因子个数，要限制其实不难，给系数加多一维即可：
     F(d)(p)表示：素因子个数<=p时，对B(d)的贡献系数
   
     分块加速思想
     你可以再纸上模拟一下：设d在[i, n/(n/i)]的区间上，则该区间内所有的n/d都是一样的。
 

``` cpp
#include <iostream>  
#include <cstdio>  
#include <cmath>  
#include <algorithm>  
using namespace std;  
#define LL long long  
#define M 500005  
#define N 19  
  
//返回n中有多少个x因子  
int cal(int n, int x)  
{  
    int res = 0;  
    do  
    {  
        ++res;  
        n /= x;  
    }  
    while (n % x == 0);  
    return res;  
}  
  
//备注：分块加速求解需要求前缀和  
//F[i][j]: 表示素因子个数<=j条件下的莫比乌斯前缀和：μ(1)+μ(2)+...+μ(i)  
int F[M][N];  
int num[M];     //num[i]: i中含有多少个素因子  
int h[M];       //h[i]: -1表示存在平方因子，否则表示有多少种素因子  
  
//莫比乌斯函数的定义  
int mob(int n)  
{  
    if (h[n] == -1) return 0;   //存在平方因子时，μ(n)=0  
    if (h[n] & 1) return -1;    //奇数个不同素数之积，μ(n)=-1  
    return 1;                   //偶数个不同素数之积，μ(n)=1  
}  
  
int main()  
{  
    int t, n, m, p, i, j;  
    //筛法算出num[]以及h[]  
    for (i = 2; i < M; i++)  
    {  
        if (num[i]) continue;  
        for (j = i; j < M; j+=i)  
        {  
            int tp = cal(j, i);  
            num[j] += tp;  
            if (tp > 1)      //j中含有多个i，必然存在平方因子  
            {  
                h[j] = -1;  
            }  
            else if (h[j] >= 0)  
            {  
                ++h[j];  
            }  
        }  
    }  
    //枚举i作为公因子，对B(j)的贡献值为：mob(j/i)  
    for (i = 1; i < M; i++)  
    {  
        for (j = i; j < M; j+=i)  
        {  
            F[j][num[i]] += mob(j/i);  
        }  
    }  
    //为了表示素因子数<=j的意义，求j的前缀和  
    for (i = 1; i < M; i++)  
    {  
        for (j = 1; j < N; j++)  
        {  
            F[i][j] += F[i][j-1];  
        }  
    }  
    //为了分组加速求解，求i的前缀和  
    for (i = 1; i < M; i++)  
    {  
        for (j = 0; j < N; j++)  
        {  
            F[i][j] += F[i-1][j];  
        }  
    }  
    scanf("%d", &t);  
    while (t--)  
    {  
        scanf("%d%d%d", &n, &m, &p);  
        LL ans = 0;  
        if (p >= N)  
        {  
            ans = (LL)n*m;  
        }  
        else  
        {  
            if (n > m)  
            {  
                n ^= m;  
                m ^= n;  
                n ^= m;  
            }  
            for (i = 1; i <= n; i = j + 1)  
            {  
                j = min(n/(n/i), m/(m/i));  
                ans += ((LL)F[j][p]-F[i-1][p])*(n/i)*(m/i);  
            }  
        }  
        printf("%I64d\n", ans);  
    }  
    return 0;  
}  
```

### 求1~r中有多少个数与n互素。
对于这个问题由容斥原理，我们有3种写法，其实效率差不多。分别是：dfs，队列数组，位运算。

先说说位运算吧：
用二进制1,0来表示第几个素因子是否被用到,如m=3，三个因子是2,3,5，则i=3时二进制是011，表示第2、3个
因子被用到

``` cpp
LL Solve(LL n,LL r)  
{  
    vector<LL> p;  
    for(LL i=2; i*i<=n; i++)  
    {  
        if(n%i==0)  
        {  
            p.push_back(i);  
            while(n%i==0) n/=i;  
        }  
    }  
    if(n>1)  
        p.push_back(n);  
    LL ans=0;  
    for(LL msk=1; msk<(1<<p.size()); msk++)  
    {  
        LL multi=1,bits=0;  
        for(LL i=0; i<p.size(); i++)  
        {  
            if(msk&(1<<i))  //判断第几个因子目前被用到  
            {  
                ++bits;  
                multi*=p[i];  
            }  
        }  
        LL cur=r/multi;  
        if(bits&1) ans+=cur;  
        else       ans-=cur;  
    }  
    return r-ans;  
}  
```
DFS实现：

``` cpp
void Solve(LL n)  
{  
    p.clear();  
    for(LL i=2; i*i<=n; i++)  
    {  
        if(n%i==0)  
        {  
            p.push_back(i);  
            while(n%i==0) n/=i;  
        }  
    }  
    if(n>1)  
        p.push_back(n);  
}  
  
void dfs(LL k,LL t,LL s,LL n)  
{  
    if(k==p.size())  
    {  
        if(t&1) ans-=n/s;  
        else    ans+=n/s;  
        return;  
    }  
    dfs(k+1,t,s,n);  
    dfs(k+1,t+1,s*p[k],n);  
}  
  
//主函数内是：  
dfs(0,0,1,r);  
```
### PollardRho大整数分解

``` cpp
#include <iostream>  
#include <stdlib.h>  
#include <string.h>  
#include <algorithm>  
#include <stdio.h>  
  
const int Times = 10;  
const int N = 5500;  
  
using namespace std;  
typedef long long LL;  
  
LL ct, cnt;  
LL fac[N], num[N];  
  
LL gcd(LL a, LL b)  
{  
    return b? gcd(b, a % b) : a;  
}  
  
LL multi(LL a, LL b, LL m)  
{  
    LL ans = 0;  
    a %= m;  
    while(b)  
    {  
        if(b & 1)  
        {  
            ans = (ans + a) % m;  
            b--;  
        }  
        b >>= 1;  
        a = (a + a) % m;  
    }  
    return ans;  
}  
  
LL quick_mod(LL a, LL b, LL m)  
{  
    LL ans = 1;  
    a %= m;  
    while(b)  
    {  
        if(b & 1)  
        {  
            ans = multi(ans, a, m);  
            b--;  
        }  
        b >>= 1;  
        a = multi(a, a, m);  
    }  
    return ans;  
}  
  
bool Miller_Rabin(LL n)  
{  
    if(n == 2) return true;  
    if(n < 2 || !(n & 1)) return false;  
    LL m = n - 1;  
    int k = 0;  
    while((m & 1) == 0)  
    {  
        k++;  
        m >>= 1;  
    }  
    for(int i=0; i<Times; i++)  
    {  
        LL a = rand() % (n - 1) + 1;  
        LL x = quick_mod(a, m, n);  
        LL y = 0;  
        for(int j=0; j<k; j++)  
        {  
            y = multi(x, x, n);  
            if(y == 1 && x != 1 && x != n - 1) return false;  
            x = y;  
        }  
        if(y != 1) return false;  
    }  
    return true;  
}  
  
LL pollard_rho(LL n, LL c)  
{  
    LL i = 1, k = 2;  
    LL x = rand() % (n - 1) + 1;  
    LL y = x;  
    while(true)  
    {  
        i++;  
        x = (multi(x, x, n) + c) % n;  
        LL d = gcd((y - x + n) % n, n);  
        if(1 < d && d < n) return d;  
        if(y == x) return n;  
        if(i == k)  
        {  
            y = x;  
            k <<= 1;  
        }  
    }  
}  
  
void find(LL n, int c)  
{  
    if(n == 1) return;  
    if(Miller_Rabin(n))  
    {  
        fac[ct++] = n;  
        return ;  
    }  
    LL p = n;  
    LL k = c;  
    while(p >= n) p = pollard_rho(p, c--);  
    find(p, k);  
    find(n / p, k);  
}  
  
int main()  
{  
    LL n;  
    while(cin>>n)  
    {  
        ct = 0;  
        find(n, 120);  
        sort(fac, fac + ct);  
        num[0] = 1;  
        int k = 1;  
        for(int i=1; i<ct; i++)  
        {  
            if(fac[i] == fac[i-1])  
                ++num[k-1];  
            else  
            {  
                num[k] = 1;  
                fac[k++] = fac[i];  
            }  
        }  
        cnt = k;  
        for(int i=0; i<cnt; i++)  
            cout<<fac[i]<<"^"<<num[i]<<" ";  
        cout<<endl;  
    }  
    return 0;  
}  
```

### 组合数取模
数据规模较大时10^9：
``` cpp
#include <iostream>  
#include <string.h>  
#include <stdio.h>  
  
using namespace std;  
typedef long long LL;  
  
LL n,m,p;  
  
LL quick_mod(LL a, LL b)  
{  
    LL ans = 1;  
    a %= p;  
    while(b)  
    {  
        if(b & 1)  
        {  
            ans = ans * a % p;  
            b--;  
        }  
        b >>= 1;  
        a = a * a % p;  
    }  
    return ans;  
}  
  
LL C(LL n, LL m)  
{  
    if(m > n) return 0;  
    LL ans = 1;  
    for(int i=1; i<=m; i++)  
    {  
        LL a = (n + i - m) % p;  
        LL b = i % p;  
        ans = ans * (a * quick_mod(b, p-2) % p) % p;  
    }  
    return ans;  
}  
  
LL Lucas(LL n, LL m)  
{  
    if(m == 0) return 1;  
    return C(n % p, m % p) * Lucas(n / p, m / p) % p;  
}  
  
int main()  
{  
    int T;  
    scanf("%d", &T);  
    while(T--)  
    {  
        scanf("%I64d%I64d%I64d", &n, &m, &p);  
        printf("%I64d\n", Lucas(n,m));  
    }  
    return 0;  
}  
```
数据规模较小时10^5：

``` stylus
#include <iostream>  
#include <string.h>  
#include <stdio.h>  
  
using namespace std;  
typedef long long LL;  
const int N = 200005;  
  
bool prime[N];  
int p[N];  
int cnt;  
  
void isprime()  
{  
    cnt = 0;  
    memset(prime,true,sizeof(prime));  
    for(int i=2; i<N; i++)  
    {  
        if(prime[i])  
        {  
            p[cnt++] = i;  
            for(int j=i+i; j<N; j+=i)  
                prime[j] = false;  
        }  
    }  
}  
  
LL quick_mod(LL a,LL b,LL m)  
{  
    LL ans = 1;  
    a %= m;  
    while(b)  
    {  
        if(b & 1)  
        {  
            ans = ans * a % m;  
            b--;  
        }  
        b >>= 1;  
        a = a * a % m;  
    }  
    return ans;  
}  
  
LL Work(LL n,LL p)  
{  
    LL ans = 0;  
    while(n)  
    {  
        ans += n / p;  
        n /= p;  
    }  
    return ans;  
}  
  
LL Solve(LL n,LL m,LL P)  
{  
    LL ans = 1;  
    for(int i=0; i<cnt && p[i]<=n; i++)  
    {  
        LL x = Work(n, p[i]);  
        LL y = Work(n - m, p[i]);  
        LL z = Work(m, p[i]);  
        x -= (y + z);  
        ans *= quick_mod(p[i],x,P);  
        ans %= P;  
    }  
    return ans;  
}  
  
int main()  
{  
    int T;  
    isprime();  
    cin>>T;  
    while(T--)  
    {  
        LL n,m,P;  
        cin>>n>>m>>P;  
        n += m - 2;  
        m--;  
        cout<<Solve(n,m,P)<<endl;  
    }  
    return 0;  
}  


```
### Bell数
Bell数的定义：第n个Bell数表示集合{1,2,3,...,n}的划分方案数；
Bell三角形的构造方法：
第一行第一个元素是1，即a[1][1] = 1
对于n>1，第n行第一项等于第n-1行最后一项，即a[n][1] = a[n-1][n-1];
对于m,n>1，第n行第m项等于它左边和左上方的两个数之和，即a[n][m] = a[n][m-1] + a[n-1][m-1];

``` cpp
void Bell(int T[],int MOD)  
{  
    B[0] = 1;  
    B[1] = 1;  
    T[0] = 1;  
    for(int i=2;i<N;i++)  
    {  
        T[i-1] = B[i-1];  
        for(int j=i-2;j>=0;j--)  
            T[j] = (T[j]+T[j+1])%MOD;  
        B[i] = T[0];  
    }  
}  


```























  [1]: ./images/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97.png "扩展欧几里得.png"
  [2]: ./images/crt.png "crt.png"