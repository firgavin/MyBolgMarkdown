---
title: ACM数论
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---


欢迎使用 **{小书匠}(xiaoshujiang)编辑器**，您可以通过==设置==里的修改模板来改变新建文章的内容。

### 素数的判定
一个数 n 如果是合数，那么它的所有的因子不超过`sqrt(n)`，复杂度是`o(n*sqrt(n))`：

``` cpp
bool prime(int x){//判断x是不是质数，是返回true，不是返回false 
    if(x <= 1) return false; 
    for(int i = 2; i <= sqrt(x + 0.5); i ++){//0.5是防止根号的精度误差 
        if(x % i == 0) return false;
    }
    return true;
}
```
或者是这样写也行：

``` cpp
bool prime(int x){//判断x是不是质数，是返回true，不是返回false 
    if(x <= 1) return false; 
    for(int i = 2; i * i <= x; i ++){//用乘法避免根号的精度误差 
        if(x % i == 0) return false;
    }
    return true;
}
//根据题目不同，如果i*i会爆int，记得开longlong
```
引入素数表来进行维护：

``` cpp
bool IsPrime(unsigned n)
{
    if ( n < 2 )
    { // 小于2的数即不是合数也不是素数
        throw 0;
    }
    static unsigned aPrimeList[] = { // 素数表
        1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,
        43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 113, 
        193, 241, 257, 337, 353, 401, 433, 449, 577, 593, 641, 
        673, 769, 881, 929, 977, 1009, 1153, 1201, 1217, 1249, 
        1297,1361, 1409, 1489, 1553, 1601, 1697, 1777, 1873, 
        1889, 2017, 2081, 2113, 2129, 2161, 2273, 2417, 2593, 
        2609, 2657, 2689, 2753, 2801, 2833, 2897, 3041, 3089, 
        3121, 3137, 3169, 3217, 3313, 3329, 3361, 3457, 3617, 
        3697, 3761, 3793, 3889, 4001, 4049, 4129, 4177, 4241, 
        4273, 4289, 4337, 4481, 4513, 4561, 4657, 4673, 4721, 
        4801, 4817, 4993, 5009, 5153, 5233, 5281, 5297, 5393, 
        5441, 5521, 5569, 5857, 5953, 6113, 6257, 6337, 6353, 
        6449, 6481, 6529, 6577, 6673, 6689, 6737, 6833, 6961, 
        6977, 7057, 7121, 7297, 7393, 7457, 7489, 7537, 7649, 
        7681, 7793, 7841, 7873, 7937, 8017, 8081, 8161, 8209, 
        8273, 8353, 8369, 8513, 8609, 8641, 8689, 8737, 8753, 
        8849, 8929, 9041, 9137, 9281, 9377, 9473, 9521, 9601, 
        9649, 9697, 9857 
    };
    
    const int nListNum = sizeof(aPrimeList)/sizeof(unsigned);//计算素数表里元素的个数
    for (unsigned i=2;i<nListNum;++i )
    { 
        if(n/2+1<aPrimeList[i])
        {
            return true;
        }
        if(0==n%aPrimeList[i])
        {
            return false;
        }
    }
   
    for (unsigned i=aPrimeList[nListNum-1];i<n/2+1;i++ )
    { 
        if (0==n%i)
        { // 除尽了，合数 
            return false;
        }
    }
    return true; 
} 
```
最后一种情况，面对大数时采用Miller-Rabbin素数测试法：
Miller-Rabbin素数测试是一个不确定的算法，只能从概率意义上判定一个数可能是素数，但并不能确保。算法流程如下:
    1.选择T个随机数A，并且有A<N成立。
    2.找到R和M，使得`N=2*R*M+1`成立。
    快速得到R和M的方式：N用二进制数B来表示，令C=B-1。因为N为奇数（素数都是奇数），所以C的最低位为0，从C的最低位的0开始向高位统计，一直到遇到第一个1。这时0的个数即为R，M为B右移R位的值。
    3.如果A^M%N=1，则通过A对于N的测试，然后进行下一个A的测试
    4.如果A^M%N!=1，那么令i由0迭代至R，进行下面的测试
    5.如果`A^((2^i)*M)%N=N-1`则通过A对于N的测试，否则进行下一个i的测试 
    6.如果i=r，且尚未通过测试，则此A对于N的测试失败，说明N为合数。
    7.进行下一个A对N的测试，直到测试完指定个数的A
    通过验证得知，当T为素数，并且A是平均分布的随机数，那么测试有效率为1 / ( 4 ^ T )。如果T > 8那么测试失误的机率就会小于10^(-5)，这对于一般的应用是足够了。如果需要求的素数极大，或着要求更高的保障度，可以适当调高T的值。

``` cpp
int Miller_Rabbin(long long n)    
{    
    long long i,s,a;    
    s=10;    //s的值可以根据需要变大    
 // randomize();    
    for(i=0;i <s;i++)    
    {    
        a=long long(rand()%(n-1)+2); //自动生成受限    
        if(modular_exp(a,n-1,n)>1)    
            return 0;    
    }    
    return 1;    
}    
long long modular_exp(long long a,long long b,long long c)//求a^b%c该函数受限    
{    
    if(a==0)    
        return 0;    
    if(b==0)    
        return 1;    
    if(b==1)    
        return a%c;    
    return (a*modular_exp(a,b-1,c))%c;    
} 
```





### 素数的筛选（构造素数表）
不采用筛素：假设我们已经我素数序列: p1, p2, .. pn
现在要判断pn+1是否是素数, 则需要(1, sqrt(pn+1)]范围内的所有素数序列,
而这个素数序列显然已经作为p1, p2, .. pn的一个子集被包含了

``` cpp
void makePrimes(int primes[], int num)
{
	int i, j, cnt;

	primes[0] = 2;
	primes[1] = 3;

	for(i = 5, cnt = 2; cnt < num; i += 2)
	{
		int flag = true;
		for(j = 1; primes[j]*primes[j] <= i; ++j)
		{
			if(i%primes[j] == 0)
				{
					flag = false; break;
				}
		}
		if(flag) primes[cnt++] = i;
	}
}
```


可以使用筛素法，复杂度`O(nloglogn)`：

``` cpp
bool prime[N];
void init(){
    for(int i = 2; i < N; i ++) prime[i] = true;
    for(int i = 2; i*i < N; i ++){//判断改成i*i<N 
        if(prime[i]){
            for(int j = i*i; j < N; j += i){//从i*i开始就可以了 
                prime[j] = false;  
            }
        }
    }
}
```
或者采用线性筛素法`O(n)`：

``` cpp
#include<cstdio>
const int N = 100000 + 5;
bool prime[N];//prime[i]表示i是不是质数 
int p[N], tot;//p[N]用来存质数 
void init(){
    for(int i = 2; i < N; i ++) prime[i] = true;//初始化为质数 
    for(int i = 2; i < N; i++){
        if(prime[i]) p[tot ++] = i;//把质数存起来 
        for(int j = 0; j < tot && i * p[j] < N; j++){
            prime[i * p[j]] = false;
            if(i % p[j] == 0) break;//保证每个合数被它最小的质因数筛去 
        }
    }    
}
int main(){
    init();
}
```



### 素数的性质


