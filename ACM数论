---
title: ACM数论
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---


欢迎使用 **{小书匠}(xiaoshujiang)编辑器**，您可以通过==设置==里的修改模板来改变新建文章的内容。

### 素数的判定
一个数 n 如果是合数，那么它的所有的因子不超过`sqrt(n)`，复杂度是`o(n*sqrt(n))`：

``` cpp
bool prime(int x){//判断x是不是质数，是返回true，不是返回false 
    if(x <= 1) return false; 
    for(int i = 2; i <= sqrt(x + 0.5); i ++){//0.5是防止根号的精度误差 
        if(x % i == 0) return false;
    }
    return true;
}
```
或者是这样写也行：

``` cpp
bool prime(int x){//判断x是不是质数，是返回true，不是返回false 
    if(x <= 1) return false; 
    for(int i = 2; i * i <= x; i ++){//用乘法避免根号的精度误差 
        if(x % i == 0) return false;
    }
    return true;
}
//根据题目不同，如果i*i会爆int，记得开longlong
```
引入素数表来进行维护：

``` cpp
bool IsPrime(unsigned n)
{
    if ( n < 2 )
    { // 小于2的数即不是合数也不是素数
        throw 0;
    }
    static unsigned aPrimeList[] = { // 素数表
        1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,
        43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 113, 
        193, 241, 257, 337, 353, 401, 433, 449, 577, 593, 641, 
        673, 769, 881, 929, 977, 1009, 1153, 1201, 1217, 1249, 
        1297,1361, 1409, 1489, 1553, 1601, 1697, 1777, 1873, 
        1889, 2017, 2081, 2113, 2129, 2161, 2273, 2417, 2593, 
        2609, 2657, 2689, 2753, 2801, 2833, 2897, 3041, 3089, 
        3121, 3137, 3169, 3217, 3313, 3329, 3361, 3457, 3617, 
        3697, 3761, 3793, 3889, 4001, 4049, 4129, 4177, 4241, 
        4273, 4289, 4337, 4481, 4513, 4561, 4657, 4673, 4721, 
        4801, 4817, 4993, 5009, 5153, 5233, 5281, 5297, 5393, 
        5441, 5521, 5569, 5857, 5953, 6113, 6257, 6337, 6353, 
        6449, 6481, 6529, 6577, 6673, 6689, 6737, 6833, 6961, 
        6977, 7057, 7121, 7297, 7393, 7457, 7489, 7537, 7649, 
        7681, 7793, 7841, 7873, 7937, 8017, 8081, 8161, 8209, 
        8273, 8353, 8369, 8513, 8609, 8641, 8689, 8737, 8753, 
        8849, 8929, 9041, 9137, 9281, 9377, 9473, 9521, 9601, 
        9649, 9697, 9857 
    };
    
    const int nListNum = sizeof(aPrimeList)/sizeof(unsigned);//计算素数表里元素的个数
    for (unsigned i=2;i<nListNum;++i )
    { 
        if(n/2+1<aPrimeList[i])
        {
            return true;
        }
        if(0==n%aPrimeList[i])
        {
            return false;
        }
    }
   
    for (unsigned i=aPrimeList[nListNum-1];i<n/2+1;i++ )
    { 
        if (0==n%i)
        { // 除尽了，合数 
            return false;
        }
    }
    return true; 
} 
```
二次探测定理：如果p是素数，且`0<x<p`，则方程`x^2=1(mod p)`的解为1或p-1。
最后一种情况，面对大数时采用Miller-Rabbin素数测试法：
Miller-Rabbin素数测试是一个不确定的算法，只能从概率意义上判定一个数可能是素数，但并不能确保。算法流程如下:
    1.选择T个随机数A，并且有A<N成立。
    2.找到R和M，使得`N=2*R*M+1`成立。
    快速得到R和M的方式：N用二进制数B来表示，令C=B-1。因为N为奇数（素数都是奇数），所以C的最低位为0，从C的最低位的0开始向高位统计，一直到遇到第一个1。这时0的个数即为R，M为B右移R位的值。
    3.如果A^M%N=1，则通过A对于N的测试，然后进行下一个A的测试
    4.如果A^M%N!=1，那么令i由0迭代至R，进行下面的测试
    5.如果`A^((2^i)*M)%N=N-1`则通过A对于N的测试，否则进行下一个i的测试 
    6.如果i=r，且尚未通过测试，则此A对于N的测试失败，说明N为合数。
    7.进行下一个A对N的测试，直到测试完指定个数的A
    通过验证得知，当T为素数，并且A是平均分布的随机数，那么测试有效率为1 / ( 4 ^ T )。如果T > 8那么测试失误的机率就会小于10^(-5)，这对于一般的应用是足够了。如果需要求的素数极大，或着要求更高的保障度，可以适当调高T的值。

``` cpp
int Miller_Rabbin(long long n)    
{    
    long long i,s,a;    
    s=10;    //s的值可以根据需要变大    
 // randomize();    
    for(i=0;i <s;i++)    
    {    
        a=long long(rand()%(n-1)+2); //自动生成受限    
        if(modular_exp(a,n-1,n)>1)    
            return 0;    
    }    
    return 1;    
}    
long long modular_exp(long long a,long long b,long long c)//求a^b%c该函数受限    
{    
    if(a==0)    
        return 0;    
    if(b==0)    
        return 1;    
    if(b==1)    
        return a%c;    
    return (a*modular_exp(a,b-1,c))%c;    
} 
```
完整版代码：

``` cpp

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
#include <iostream>
#include <math.h>

using namespace std;
const int Times = 10;
typedef long long LL;

LL multi(LL a, LL b, LL m)
{
    LL ans = 0;
    a %= m;
    while(b)
    {
        if(b & 1)
        {
            ans = (ans + a) % m;
            b--;
        }
        b >>= 1;
        a = (a + a) % m;
    }
    return ans;
}

LL quick_mod(LL a, LL b, LL m)
{
    LL ans = 1;
    a %= m;
    while(b)
    {
        if(b & 1)
        {
            ans = multi(ans, a, m);
            b--;
        }
        b >>= 1;
        a = multi(a, a, m);
    }
    return ans;
}

bool Miller_Rabin(LL n)
{
    if(n == 2) return true;
    if(n < 2 || !(n & 1)) return false;
    LL m = n - 1;
    int k = 0;
    while((m & 1) == 0)
    {
        k++;
        m >>= 1;
    }
    for(int i=0; i<Times; i++)
    {
        LL a = rand() % (n - 1) + 1;
        LL x = quick_mod(a, m, n);
        LL y = 0;
        for(int j=0; j<k; j++)
        {
            y = multi(x, x, n);
            if(y == 1 && x != 1 && x != n - 1) return false;
            x = y;
        }
        if(y != 1) return false;
    }
    return true;
}

int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        LL n;
        scanf("%I64d",&n);
        if(Miller_Rabin(n)) puts("Yes");
        else puts("No");
    }
    return 0;
}

```
质数检测Java大数版：

``` java
import java.io.*;
import java.util.*;
import java.math.BigInteger;
 
public class Main{
	    public static final int Times = 10;
	    
	    public static BigInteger quick_mod(BigInteger a,BigInteger b,BigInteger m){
	    		BigInteger ans = BigInteger.ONE;
	    		a = a.mod(m);
	    		while(!(b.equals(BigInteger.ZERO))){
	    				if((b.mod(BigInteger.valueOf(2))).equals(BigInteger.ONE)){
	    						ans = (ans.multiply(a)).mod(m);
	    						b = b.subtract(BigInteger.ONE);
	    				}
	    				b = b.divide(BigInteger.valueOf(2));
	    				a = (a.multiply(a)).mod(m);
	    		}
	    		return ans;
	    }
	    
	 	public static boolean Miller_Rabin(BigInteger n){
	 			if(n.equals(BigInteger.valueOf(2))) return true;
	 			if(n.equals(BigInteger.ONE)) return false;
	 			if((n.mod(BigInteger.valueOf(2))).equals(BigInteger.ZERO)) return false;
	 			BigInteger m = n.subtract(BigInteger.ONE);
	 			BigInteger y = BigInteger.ZERO;
	 			int k = 0;
	 			while((m.mod(BigInteger.valueOf(2))).equals(BigInteger.ZERO)){
	 					k++;
	 					m = m.divide(BigInteger.valueOf(2));
	 			}
	 			Random d = new Random();
	 			for(int i=0;i<Times;i++){
	 				    int t = 0;
	 				    if(n.compareTo(BigInteger.valueOf(10000)) == 1){
	 				    		t = 10000;
	 				    }else{
	 				    	    t = n.intValue() - 1;
	 				    }
	 					int a = d.nextInt(t) + 1;
	 					BigInteger x = quick_mod(BigInteger.valueOf(a),m,n);
	 					for(int j=0;j<k;j++){
	 							y = (x.multiply(x)).mod(n);
	 							if(y.equals(BigInteger.ONE) && !(x.equals(BigInteger.ONE)) && !(x.equals(n.subtract(BigInteger.ONE)))) return false;
	 							x = y;
	 					}
	 					if(!(y.equals(BigInteger.ONE))) return false;
	 			}
	 			return true;
	 	}
	 	
		public static void main(String[] args){
				Scanner cin = new Scanner(System.in);
				while(cin.hasNextBigInteger()){
						BigInteger n = cin.nextBigInteger();
						if(Miller_Rabin(n)) System.out.println("Yes");
						else System.out.println("No");
				}
		}
}
 
```






### 素数的筛选（构造素数表）
不采用筛素：假设我们已经我素数序列: p1, p2, .. pn
现在要判断pn+1是否是素数, 则需要(1, sqrt(pn+1)]范围内的所有素数序列,
而这个素数序列显然已经作为p1, p2, .. pn的一个子集被包含了

``` cpp
void makePrimes(int primes[], int num)
{
	int i, j, cnt;

	primes[0] = 2;
	primes[1] = 3;

	for(i = 5, cnt = 2; cnt < num; i += 2)
	{
		int flag = true;
		for(j = 1; primes[j]*primes[j] <= i; ++j)
		{
			if(i%primes[j] == 0)
				{
					flag = false; break;
				}
		}
		if(flag) primes[cnt++] = i;
	}
}
```


可以使用筛素法，复杂度`O(nloglogn)`：

``` cpp
bool prime[N];
void init(){
    for(int i = 2; i < N; i ++) prime[i] = true;
    for(int i = 2; i*i < N; i ++){//判断改成i*i<N 
        if(prime[i]){
            for(int j = i*i; j < N; j += i){//从i*i开始就可以了 
                prime[j] = false;  
            }
        }
    }
}
```
或者采用线性筛素法`O(n)`：

``` cpp
#include<cstdio>
const int N = 100000 + 5;
bool prime[N];//prime[i]表示i是不是质数 
int p[N], tot;//p[N]用来存质数 
void init(){
    for(int i = 2; i < N; i ++) prime[i] = true;//初始化为质数 
    for(int i = 2; i < N; i++){
        if(prime[i]) p[tot ++] = i;//把质数存起来 
        for(int j = 0; j < tot && i * p[j] < N; j++){
            prime[i * p[j]] = false;
            if(i % p[j] == 0) break;//保证每个合数被它最小的质因数筛去 
        }
    }    
}
int main(){
    init();
}
```



### 素数的性质

### 幂乘快速计算（二分思想）
逆向思维，不断地二分，累积底数的平方即可：

``` cpp
typedef long long LL;

LL pow_mod(LL a, LL b, LL p){//a的b次方求余p 
    LL ret = 1;
    while(b){
        if(b & 1) ret = (ret * a) % p;
        a = (a * a) % p;
        b >>= 1;
    }
    return ret;
}
```
衍生出ll的快速乘：

``` cpp
LL mul(LL a, LL b, LL p){//快速乘，计算a*b%p 
    LL ret = 0;
    while(b){
        if(b & 1) ret = (ret + a) % p;
        a = (a + a) % p;
        b >>= 1;
    }
    return ret;
}
```
关于计算结果过除以MOD取余的问题：
1、计算加法每相加一次执行一次取余；
2、计算减法给被减数加上MOD之后先减法后取余；
3、计算乘法每相乘一次取余一次。

### GCD&LCM的相关
计算gcd循环写法和递归写法：

``` cpp
LL gcd(LL a, LL b){
    if(b == 0) return a;
    else return gcd(b, a%b);
}

LL gcd(LL a, LL b){
    return b ? gcd(b, a%b) : a;
}

LL gcd(LL a, LL b){
    LL t;
    while(b){
        t = b;
        b = a % b;
        a = t;
    }
    return a;
}
```
相关的公式：

``` stylus
a*b = gcd(a,b) * lcm(a,b)
gcd(ka, kb) = k * gcd(a, b)
lcm(ka, kb) = k * lcm(a, b)
lcm(S/a, S/b) = S/gcd(a, b)
```

### 扩展欧几里德算法
那么已知 a，b 求 一组解 x，y 满足 ax+by = gcd(a, b) 这个公式:

![enter description here][1]

代码模板：
 
``` cpp
#include<cstdio>
typedef long long LL;
void ex_Eulid(LL a, LL b, LL &x, LL &y, LL &d){
    if (!b) {d = a, x = 1, y = 0;}
    else{
        extend_Eulid(b, a % b, y, x, d);
        y -= x * (a / b);
    }
}
int main(){
    LL a, b, d, x, y;
    while(~scanf("%lld%lld", &a, &b)){
        ex_Eulid(a, b, x, y, d);
        printf("%lld*a + %lld*b = %lld\n", x, y, d);
    }
}
```

### 威尔逊定理
当且仅当p为素数时：( p -1 )! ≡ -1 ( mod p )
或者这么写( p -1 )! ≡ p-1 ( mod p )
若p为质数，则p能被(p-1)!+1整除
在初等数论中，这是威尔逊给出了判定一个自然数是否为素数的充分必要条件。

### 欧拉定理
欧拉定理，也称费马-欧拉定理
若n,a为正整数，且n,a互质，即gcd(a,n) = 1，则a^φ(n) ≡ 1 (mod n)
 
φ(n) 是欧拉函数，欧拉函数是求小于等于n的数中与n互质的数的数目  
欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目或者说欧拉函数是求 1到n-1 中 与n互质的数的数目。
 
如果n是质数那么1到n-1所有数都是与n互质的，所以φ(n) = n-1

### 中国剩余定理
![CRT问题描述][2]

CRT问题代码描述如下：

``` cpp
void extend_Euclid(LL a, LL b, LL &x, LL &y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return;
    }
    extend_Euclid(b, a % b, x, y);
    LL tmp = x;
    x = y;
    y = tmp - (a / b) * y;
}

int CRT(int a[],int m[],int n)
{
    int M = 1;
    int ans = 0;
    for(int i=1; i<=n; i++)
        M *= m[i];
    for(int i=1; i<=n; i++)
    {
        int x, y;
        int Mi = M / m[i];
        extend_Euclid(Mi, m[i], x, y);
        ans = (ans + Mi * x * a[i]) % M;
    }
    if(ans < 0) ans += M;
    return ans;
}
```


### 费马小定理
假如p是质数：
若p不能整除a，则 a^(p-1) ≡1（mod p）；
若p能整除a，则a^(p-1) ≡0（mod p）。
或者说，若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。

### 高斯消元
高斯消元是用来求线性方程组的解，行列式求值，或者矩阵求逆等等。主要有两个步骤：化行阶梯形矩阵和回带。
高斯消元的时间复杂度为O(n^3)，以下代码中n代表方程个数，m代表未知数个数，数组f用来判断哪些未知数是
变元，数组x用来存求得的解。

``` cpp
#include <iostream>
#include <string.h>
#include <algorithm>
#include <stdio.h>
#include <math.h>

using namespace std;
const int N = 105;

int gcd(int a,int b)
{
    return b ? gcd(b,a%b):a;
}

int lcm(int a,int b)
{
    return a / gcd(a,b) * b;
}

/**n个方程，m个未知数，r代表当前处理的行，c代表当前处理的列*/
void Gauss(int a[][N],int n,int m,int &r,int &c)
{
    r = c = 0;
    for(; r<n && c<m; r++,c++)
    {
        int maxi = r;
        for(int i=r+1; i<n; i++)
            if(abs(a[i][c]) > abs(a[maxi][c]))
                maxi = i;
        if(maxi != r)
        {
            for(int i=r; i<m+1; i++)
                swap(a[r][i],a[maxi][i]);
        }
        if(a[r][c] == 0)
        {
            r--;
            continue;
        }
        for(int i=r+1; i<n; i++)
        {
            if(a[i][c] != 0)
            {
                int x = abs(a[i][c]);
                int y = abs(a[r][c]);
                int LCM = lcm(x,y);
                int tx = LCM / x;
                int ty = LCM / y;
                if(a[i][c] * a[r][c] < 0)
                    ty = -ty;
                for(int j=c; j<m+1; j++)
                    a[i][j] = a[i][j] * tx - a[r][j] * ty;
            }
        }
    }
}

int Rewind(int a[][N],int x[],bool f[],int n,int m,int r,int c)
{
    for(int i=r; i<n; i++)
        if(a[i][c] != 0)
            return -1;
    if(r < m)
    {
        memset(f,1,sizeof(f));
        for(int i=r-1; i>=0; i--)
        {
            int id = 0;
            int cnt = 0;
            for(int j=0; j<m; j++)
            {
                if(a[i][j] != 0 && f[j])
                {
                    cnt++;
                    id = j;
                }
            }
            if(cnt > 1) continue;
            int t = a[i][m];
            for(int j=0; j<m; j++)
            {
                if(a[i][j] != 0 && j != id)
                    t -= a[i][j] * x[j];
            }
            x[id] = t / a[i][id];
            f[id] = 0;
        }
        return m - r;
    }
    for(int i=r-1; i>=0; i--)
    {
        int t = a[i][c];
        for(int j=i+1; j<c; j++)
        {
            if(a[i][j] != 0)
                t -= a[i][j] * x[j];
        }
        if(t % a[i][i] != 0) return -2;
        x[i] = t / a[i][i];
    }
    return 0;
}

void Print(int a[][N],int n,int m)
{
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<m+1; j++)
            cout<<a[i][j]<<" ";
        cout<<endl;
    }
}

int a[N][N];
int x[N];
bool f[N];

int main()
{
    int n,m;
    while(cin>>n>>m)
    {
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<m+1; j++)
                cin>>a[i][j];
        }
        int r,c;
        Gauss(a,n,m,r,c);
        Rewind(a,x,f,n,m,r,c);
        Print(a,n,m);
        puts("");
    }
    return 0;
}
```

### 求n!，C(n,m)，A(n,m)最后的非零位

> 先说说怎样求n!最后的非零位吧！
> 比如找10！最后的非零位，由于质因数2和5的组合之后末尾会产生0，所以我们先把2，5的质因子全部去掉，由于2的数目要比5多，所以我们要在最后考虑
> 多余的2对末尾的影响。 比如：1*2*3*4*5*6*7*8*9*10去掉2，5的因子后就是：
> 1*1*3*1*1*3*7*1*9*1，由于去掉了2，5，那么剩下的数字末尾一定是3，7，9，1四者之一，然后我们再求出这么一串数相乘以后末尾的数是几，最后再补上 2对末位的影响即可。 所以，求n！最后非零位分为4步： (1)将n！中所有的2，5因子去掉 (2)求出剩下的一串数字相乘后末尾的那个数
> (3)由于2比5多，考虑多余的2对结果的影响 (4)输出答案 对于步骤(1)，直接计算去除就行了，很简单。
> 对于步骤(2)，是难点，这个问题可以转化为求出这些数里面末尾是3，7，9的数字出现的次数，因为这些数的n次方是有规律的，周期为4.
> 现在的问题就是如何求出这串数字末尾3，7，9各自出现的次数了。 一个数列实际上可以分为偶数列和奇数列。
> 例如：1*2*3*4*5*6*7*8*9*10 分成：1，3，5，7，9和2，4，6，8，10两部分
> 这样我们尝试分别进行统计，可以发现，实际上2，4，6，8，10中的个数也就是1，2，3，4，5中的个数，也就是说我们又把这个问题划分成了一个原来问
> 题的子问题。
> f(n)=f(n/2)+g(n)，g(n)表示奇数列中的数目，我们需要解决g(n)，再次观察g(n)，实际上又分成了两部分：1，3，7，9，11，13，17，19，21....................
> 以及5的奇倍数5，15，25，........ 说明又出现了子问题。 如果要统计这个数列中末尾为x(x为1，3，7，9)的个数可以这样写：
> g(n,x)=n/10+(n%10>=x)+g(n/5,x)
> 这样利用了两个递归方程，我们可以在logn的时间内计算出末尾为1，3，7，9的数的个数了
> 在得到这串数字中末尾是3，7，9的数字个数后，再利用循环节的性质可以快速求出这串数字相乘后mod10的结果，再考虑当时多余的2，便可以求出答案。
> 知道了这个之后，求A(n,m)就不难了。 先求出n！和(n-m)!中2，5，3，7，9分别出现的次数，然后各自相减，再用循环节处理即可。
> 这里还要注意一下：2的出现次数如果小于5的出现次数，我们可以直接输出5，如果2的出现次数等于5的出现次数，那么2的循环节不需要考虑。至于3，
> 7，9的循环节，由于这些数的4次方末尾刚好为1，所以不需要特殊考虑

题目：n!的最后的非零数字

``` cpp
#include<stdio.h>  
#include<string.h>  
  
#define maxn 10001  
  
const int mod[20]={1,1,2,6,4,2,2,4,2,8,4,4,8,4,6,8,8,6,8,2};  
  
int lastdigit(char buf[])  
{  
    int len=strlen(buf),a[maxn],i,c,ret=1;  
    if(len==1)return mod[buf[0]-'0'];  
    for(i=0;i<len;i++)  
        a[i]=buf[len-1-i]-'0';  
    while(len)  
    {  
        ret=ret*mod[a[1]%2*10+a[0]]%5;  
        for(c=0,i=len-1;i>=0;i--)  
        {  
            c=c*10+a[i],a[i]=c/5,c%=5;  
        }  
        len-=!a[len-1];  
    }  
    return ret+ret%2*5;  
}  
  
int main()  
{  
    char  n[maxn];  
    while(scanf("%s",n)!=EOF)  
    {  
        printf("%d\n",lastdigit(n));  
    }  
    return 0;  
}  


```


题目：求A(n,m)最后的非零位数字。

``` cpp
#include <iostream>  
  
using namespace std;  
  
int GetCount(int n,int x)    /**计算n!中质因子x出现的次数*/  
{  
    if(n==0) return 0;  
    return n/x+GetCount(n/x,x);  
}  
  
int g(int n,int x)           /**计算f(1)到f(n)中奇数数列中末尾为x的数出现的次数*/  
{  
    if(n==0) return 0;  
    return n/10+(n%10>=x)+g(n/5,x);  
}  
  
int getx(int n,int x)        /**计算f(1)到f(n)中，末尾为x的数的出现次数*/  
{  
    if(n==0) return 0;  
    return getx(n/2,x)+g(n,x);  
}  
  
int table[4][4]=  
{  
     6,2,4,8,  
     1,3,9,7,  
     1,7,9,3,  
     1,9,1,9  
};  
  
int main()  
{  
    int n,m;  
    int num2,num3,num5,num7,num9;  
    while(cin>>n>>m)  
    {  
        num2=GetCount(n,2)-GetCount(n-m,2);  
        num5=GetCount(n,5)-GetCount(n-m,5);  
        num3=getx(n,3)-getx(n-m,3);  
        num7=getx(n,7)-getx(n-m,7);  
        num9=getx(n,9)-getx(n-m,9);  
        int ans=1;  
        if(num5>num2)  
        {  
            cout<<"5"<<endl;  
            continue;  
        }  
        if(num2!=num5)  
        {  
            ans*=table[0][(num2-num5)%4];  
            ans%=10;  
        }  
        ans*=table[1][num3%4];  
        ans%=10;  
        ans*=table[2][num7%4];  
        ans%=10;  
        ans*=table[3][num9%4];  
        ans%=10;  
        cout<<ans<<endl;  
    }  
    return 0;  
}  
```
题目：求C(n,m)最后的非零位数字。

``` cpp
#include <iostream>  
  
using namespace std;  
  
int GetCount(int n,int x)    /**计算n!中质因子x出现的次数*/  
{  
    if(n==0) return 0;  
    return n/x+GetCount(n/x,x);  
}  
  
int g(int n,int x)           /**计算f(1)到f(n)中奇数数列中末尾为x的数出现的次数*/  
{  
    if(n==0) return 0;  
    return n/10+(n%10>=x)+g(n/5,x);  
}  
  
int getx(int n,int x)        /**计算f(1)到f(n)中，末尾为x的数的出现次数*/  
{  
    if(n==0) return 0;  
    return getx(n/2,x)+g(n,x);  
}  
  
int table[4][4]=  
{  
     6,2,4,8,  
     1,3,9,7,  
     1,7,9,3,  
     1,9,1,9  
};  
  
int main()  
{  
    int n,m;  
    int num2,num3,num5,num7,num9;  
    while(cin>>n>>m)  
    {  
        num2=GetCount(n,2)-GetCount(n-m,2)-GetCount(m,2);  
        num5=GetCount(n,5)-GetCount(n-m,5)-GetCount(m,5);  
        num3=getx(n,3)-getx(n-m,3)-getx(m,3);  
        num7=getx(n,7)-getx(n-m,7)-getx(m,7);  
        num9=getx(n,9)-getx(n-m,9)-getx(m,9);  
        int ans=1;  
        if(num5>num2)  
        {  
            cout<<"5"<<endl;  
            continue;  
        }  
        if(num2!=num5)  
        {  
            ans*=table[0][(num2-num5)%4];  
            ans%=10;  
        }  
        ans*=table[1][(num3%4+4)%4];  
        ans%=10;  
        ans*=table[2][(num7%4+4)%4];  
        ans%=10;  
        ans*=table[3][(num9%4+4)%4];  
        ans%=10;  
        cout<<ans<<endl;  
    }  
    return 0;  
}  
```

### 大数开方模板

``` cpp
#include <stdio.h>  
#include <string.h>  
#include <stdlib.h>  
  
#define DEPTH 10  
  
typedef int BigInteger[10100];  
  
int comp(const BigInteger a,const int c,const int d,const BigInteger b) //大数比较  
{  
    int i,t=0,O=-DEPTH*2;  
    if(b[0]-a[0]<d&&c) return 1;  
    for(i=b[0];i>d;i--)  
    {  
        t=t*DEPTH+a[i-d]*c-b[i];  
        if(t>0) return 1;  
        if(t<O) return 0;  
    }  
    for(i=d;i;i--)  
    {  
        t=t*DEPTH-b[i];  
        if(t>0) return 1;  
        if(t<O) return 0;  
    }  
    return t>0;  
}  
  
void sub(BigInteger a,const BigInteger b,const int c,const int d) //大数减  
{  
    int i,O=b[0]+d;  
    for(i=1+d;i<=O;i++)  
        if((a[i]-=b[i-d]*c)<0)  
            a[i+1]+=(a[i]-DEPTH+1)/DEPTH,a[i]-=(a[i]-DEPTH+1)/DEPTH*DEPTH;  
    for(;a[i]<0;a[i+1]+=(a[i]-DEPTH+1)/DEPTH,a[i]-=(a[i]-DEPTH+1)/DEPTH*DEPTH,i++);  
    for(;!a[a[0]]&&a[0]>1;a[0]--);  
}  
  
void Sqrt(BigInteger b,BigInteger a) //开平方  
{  
    int h,l,m,i;  
    memset((void*)b,0,sizeof(BigInteger));  
    for(i= b[0]=(a[0]+1)>>1;i;sub(a,b,m,i-1),b[i]+=m,i--)  
        for(h=DEPTH-1,l=0,b[i]=m=(h+l+1)>>1;h>l;b[i]=m=(h+l+1)>>1)  
            if(comp(b,m,i-1,a)) h=m-1;  
            else l = m;  
    for(;!b[b[0]]&&b[0]>1;b[0]--);  
    for (i = 1; i <= b[0]; b[i++] >>= 1);  
}  
  
char str[10100];  
BigInteger a,b;  
  
int main()  
{  
    int t;  
    scanf("%d", &t);  
    while(t--)  
    {  
        scanf("%s",str);  
        a[0]=strlen(str);  
        for(int i=1; i<=a[0]; i++)  
            a[i]=str[a[0]-i]-'0';  
        Sqrt(b,a);  
        for(int i=b[0]; i>=1; i--)  
            printf("%d",b[i]);  
        printf("\n");  
        if(t)  
            puts("");  
    }  
    return 0;  
}  
```
### 高精度进制转换
数字以a进制的形式给出，要求转化为b进制输出

``` cpp
#include <stdio.h>  
#include <string.h>  
#include <stdlib.h>  
  
#define MAXSIZE 60000  
  
char in[MAXSIZE];  
int oldbase,newbase;  
int a[MAXSIZE],b[MAXSIZE],r[MAXSIZE];  
  
inline int getNum(char c)  
{  
    if(c >= '0' && c <= '9') return c - '0';  
    if(c >= 'A' && c<= 'Z' ) return c - 'A' + 10;  
    return c - 'a' + 36;  
}  
  
inline char getChar(int i)  
{  
    if(i >= 0 && i <= 9) return i + '0';  
    if(i >= 10 && i <= 35) return i - 10 + 'A';  
    return i - 36 + 'a';  
}  
  
inline void chToNum()  
{  
    a[0] = strlen(in);  
    for(int i=1;i<=a[0];i++)  
    {  
        a[i] = getNum(in[i-1]);  
    }  
}  
  
void alter()  
{  
    while(a[0] >= 1)  
    {  
        int i,t = 0;  
        for(i=1;i<=a[0];i++)  
        {  
            t = t * oldbase + a[i];  
            b[ ++b[0] ] = t / newbase;  
            t %= newbase;  
        }  
        r[ ++r[0] ] = t;  
        b[0] = a[0];  
        for(i = 1; i <= b[0] && !b[i]; i++) ;  
        for(a[0] = 0; i <= b[0]; i++) a[ ++a[0] ] = b[i];  
        memset(b,0,sizeof(b));  
    }  
}  
  
void print()  
{  
    printf("%d %s\n%d ",oldbase,in,newbase);  
    while(r[0]>=1)  
    {  
        printf("%c",getChar(r[ r[0]-- ]));  
    }  
    printf("\n\n");  
}  
  
int main()  
{  
    int n;  
    while(scanf("%d",&n)!=EOF)  
    {  
        while(n--)  
        {  
            scanf("%d %d %s",&oldbase,&newbase,in);  
            chToNum();  
            alter();  
            print();  
        }  
    }  
    return 0;  
}  
```
### 动态区间求第k大的数字
题意：N<=50000 M<=10000，给定一个数组A[1]~A[N]，有M个操作
每个操作可以如下
Q i j t 输出 A[I]~A[J]之间第t小的数
C i t 将A[I]赋值为t

``` cpp
#include <cstdio>  
#include <cstring>  
#include <cstdlib>  
#include <iostream>  
#include <algorithm>  
  
using namespace std;  
  
#define N 60010  
#define M 10010  
#define INF 1000000000  
  
char ctrl[M][3];  
int cnt,n,m;  
int P[M],Q[M],a[N],b[N],K[M];  
  
struct treap  
{  
   int key,wei,cnt,size,ch[2];  
}T[N * 15];  
  
int tree[N << 1],nodecnt,root;  
  
void init()  
{  
   T[0].size = 0;  
   T[0].wei = -INF;  
   nodecnt = root = 0;  
}  
  
int ID(int l,int r)  
{  
    return l + r | l != r;  
}  
  
void update(int x)  
{  
   T[x].size = T[T[x].ch[0]].size + T[T[x].ch[1]].size + T[x].cnt;  
}  
  
void rotate(int &x,int t)  
{  
   int y = T[x].ch[t];  
   T[x].ch[t] = T[y].ch[!t];  
   T[y].ch[!t] = x;  
   update(x);  
   update(y);  
   x = y;  
}  
  
void insert(int &x,int t)  
{  
   if (!x)  
   {  
       x = ++ nodecnt;  
       T[x].key = t;  
       T[x].wei = rand();  
       T[x].cnt = 1;  
       T[x].ch[0] = T[x].ch[1] = 0;  
   }  
   else if (T[x].key == t)  
       T[x].cnt ++;  
   else  
   {  
       int k = T[x].key < t;  
       insert(T[x].ch[k],t);  
       if (T[x].wei < T[T[x].ch[k]].wei)  
           rotate(x,k);  
   }  
   update(x);  
}  
  
void erase(int &x,int t)  
{  
   if (T[x].key == t)  
   {  
       if (T[x].cnt == 1)  
       {  
           if (!T[x].ch[0] && !T[x].ch[1])  
           {  
               x = 0;  
               return;  
           }  
           rotate(x,T[T[x].ch[0]].wei < T[T[x].ch[1]].wei);  
           erase(x,t);  
       }  
       else T[x].cnt--;  
   }  
   else  
       erase(T[x].ch[T[x].key < t],t);  
   update(x);  
}  
  
int select(int x,int t)  
{  
   if (!x) return 0;  
   if (T[x].key > t) return select(T[x].ch[0],t);  
   return T[x].cnt + T[T[x].ch[0]].size + select(T[x].ch[1],t);  
}  
  
void treeins(int l,int r,int i,int x)  
{  
   insert(tree[ID(l,r)],x);  
   if (l == r) return;  
   int m = l + r >> 1;  
   if (i <= m) treeins(l,m,i,x);  
   else treeins(m + 1,r,i,x);  
}  
  
void treedel(int l,int r,int i,int x)  
{  
   erase(tree[ID(l,r)],x);  
   if (l == r) return;  
   int m = l + r >> 1;  
   if (i <= m) treedel(l,m,i,x);  
   else treedel(m + 1,r,i,x);  
}  
  
int query(int l,int r,int x,int y,int t)  
{  
   if (l == r) return l;  
   int m = l + r >> 1;  
   int ans = select(tree[ID(l,m)],y) - select(tree[ID(l,m)],x);  
   if (ans >= t) return query(l,m,x,y,t);  
   return query(m + 1,r,x,y,t - ans);  
}  
  
int main()  
{  
   int Times;  
   scanf("%d",&Times);  
   while (Times --)  
   {  
       scanf("%d%d",&n,&m);  
       memset(tree,0,sizeof tree);  
       init();  
       cnt = 0;  
       for (int i = 1;i <= n;i ++)  
           scanf("%d",&a[i]),b[++ cnt] = a[i];  
       for (int i = 1;i <= m;i ++)  
       {  
           scanf("%s%d%d",ctrl[i],&P[i],&Q[i]);  
           if (ctrl[i][0] == 'Q')  
               scanf("%d",&K[i]);  
           else  
               b[++ cnt] = Q[i];  
       }  
       sort(b + 1,b + 1 + cnt);  
       cnt = unique(b + 1,b + 1 + cnt) - b - 1;  
       for (int i = 1;i <= n;i ++)  
       {  
           a[i] = lower_bound(b + 1,b + 1 + cnt,a[i]) - b;  
           treeins(1,cnt,a[i],i);  
       }  
       for(int i = 1;i <= m;i ++)  
       {  
           if (ctrl[i][0] == 'Q')  
           {  
               int id = query(1,cnt,P[i] - 1,Q[i],K[i]);  
               printf("%d\n",b[id]);  
           }  
           else  
           {  
               treedel(1,cnt,a[P[i]],P[i]);  
               a[P[i]] = lower_bound(b + 1,b + 1 + cnt,Q[i]) - b;  
               treeins(1,cnt,a[P[i]],P[i]);  
           }  
       }  
   }  
   return 0;  
}  


```



  [1]: ./images/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97.png "扩展欧几里得.png"
  [2]: ./images/crt.png "crt.png"