---
title: ACM数论
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---


欢迎使用 **{小书匠}(xiaoshujiang)编辑器**，您可以通过==设置==里的修改模板来改变新建文章的内容。

### 素数的判定
一个数 n 如果是合数，那么它的所有的因子不超过`sqrt(n)`，复杂度是`o(n*sqrt(n))`：

``` cpp
bool prime(int x){//判断x是不是质数，是返回true，不是返回false 
    if(x <= 1) return false; 
    for(int i = 2; i <= sqrt(x + 0.5); i ++){//0.5是防止根号的精度误差 
        if(x % i == 0) return false;
    }
    return true;
}
```
或者是这样写也行：

``` cpp
bool prime(int x){//判断x是不是质数，是返回true，不是返回false 
    if(x <= 1) return false; 
    for(int i = 2; i * i <= x; i ++){//用乘法避免根号的精度误差 
        if(x % i == 0) return false;
    }
    return true;
}
//根据题目不同，如果i*i会爆int，记得开longlong
```
引入素数表来进行维护：

``` cpp
bool IsPrime(unsigned n)
{
    if ( n < 2 )
    { // 小于2的数即不是合数也不是素数
        throw 0;
    }
    static unsigned aPrimeList[] = { // 素数表
        1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,
        43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 113, 
        193, 241, 257, 337, 353, 401, 433, 449, 577, 593, 641, 
        673, 769, 881, 929, 977, 1009, 1153, 1201, 1217, 1249, 
        1297,1361, 1409, 1489, 1553, 1601, 1697, 1777, 1873, 
        1889, 2017, 2081, 2113, 2129, 2161, 2273, 2417, 2593, 
        2609, 2657, 2689, 2753, 2801, 2833, 2897, 3041, 3089, 
        3121, 3137, 3169, 3217, 3313, 3329, 3361, 3457, 3617, 
        3697, 3761, 3793, 3889, 4001, 4049, 4129, 4177, 4241, 
        4273, 4289, 4337, 4481, 4513, 4561, 4657, 4673, 4721, 
        4801, 4817, 4993, 5009, 5153, 5233, 5281, 5297, 5393, 
        5441, 5521, 5569, 5857, 5953, 6113, 6257, 6337, 6353, 
        6449, 6481, 6529, 6577, 6673, 6689, 6737, 6833, 6961, 
        6977, 7057, 7121, 7297, 7393, 7457, 7489, 7537, 7649, 
        7681, 7793, 7841, 7873, 7937, 8017, 8081, 8161, 8209, 
        8273, 8353, 8369, 8513, 8609, 8641, 8689, 8737, 8753, 
        8849, 8929, 9041, 9137, 9281, 9377, 9473, 9521, 9601, 
        9649, 9697, 9857 
    };
    
    const int nListNum = sizeof(aPrimeList)/sizeof(unsigned);//计算素数表里元素的个数
    for (unsigned i=2;i<nListNum;++i )
    { 
        if(n/2+1<aPrimeList[i])
        {
            return true;
        }
        if(0==n%aPrimeList[i])
        {
            return false;
        }
    }
   
    for (unsigned i=aPrimeList[nListNum-1];i<n/2+1;i++ )
    { 
        if (0==n%i)
        { // 除尽了，合数 
            return false;
        }
    }
    return true; 
} 
```
二次探测定理：如果p是素数，且`0<x<p`，则方程`x^2=1(mod p)`的解为1或p-1。
最后一种情况，面对大数时采用Miller-Rabbin素数测试法：
Miller-Rabbin素数测试是一个不确定的算法，只能从概率意义上判定一个数可能是素数，但并不能确保。算法流程如下:
    1.选择T个随机数A，并且有A<N成立。
    2.找到R和M，使得`N=2*R*M+1`成立。
    快速得到R和M的方式：N用二进制数B来表示，令C=B-1。因为N为奇数（素数都是奇数），所以C的最低位为0，从C的最低位的0开始向高位统计，一直到遇到第一个1。这时0的个数即为R，M为B右移R位的值。
    3.如果A^M%N=1，则通过A对于N的测试，然后进行下一个A的测试
    4.如果A^M%N!=1，那么令i由0迭代至R，进行下面的测试
    5.如果`A^((2^i)*M)%N=N-1`则通过A对于N的测试，否则进行下一个i的测试 
    6.如果i=r，且尚未通过测试，则此A对于N的测试失败，说明N为合数。
    7.进行下一个A对N的测试，直到测试完指定个数的A
    通过验证得知，当T为素数，并且A是平均分布的随机数，那么测试有效率为1 / ( 4 ^ T )。如果T > 8那么测试失误的机率就会小于10^(-5)，这对于一般的应用是足够了。如果需要求的素数极大，或着要求更高的保障度，可以适当调高T的值。

``` cpp
int Miller_Rabbin(long long n)    
{    
    long long i,s,a;    
    s=10;    //s的值可以根据需要变大    
 // randomize();    
    for(i=0;i <s;i++)    
    {    
        a=long long(rand()%(n-1)+2); //自动生成受限    
        if(modular_exp(a,n-1,n)>1)    
            return 0;    
    }    
    return 1;    
}    
long long modular_exp(long long a,long long b,long long c)//求a^b%c该函数受限    
{    
    if(a==0)    
        return 0;    
    if(b==0)    
        return 1;    
    if(b==1)    
        return a%c;    
    return (a*modular_exp(a,b-1,c))%c;    
} 
```
完整版代码：

``` cpp

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
#include <iostream>
#include <math.h>

using namespace std;
const int Times = 10;
typedef long long LL;

LL multi(LL a, LL b, LL m)
{
    LL ans = 0;
    a %= m;
    while(b)
    {
        if(b & 1)
        {
            ans = (ans + a) % m;
            b--;
        }
        b >>= 1;
        a = (a + a) % m;
    }
    return ans;
}

LL quick_mod(LL a, LL b, LL m)
{
    LL ans = 1;
    a %= m;
    while(b)
    {
        if(b & 1)
        {
            ans = multi(ans, a, m);
            b--;
        }
        b >>= 1;
        a = multi(a, a, m);
    }
    return ans;
}

bool Miller_Rabin(LL n)
{
    if(n == 2) return true;
    if(n < 2 || !(n & 1)) return false;
    LL m = n - 1;
    int k = 0;
    while((m & 1) == 0)
    {
        k++;
        m >>= 1;
    }
    for(int i=0; i<Times; i++)
    {
        LL a = rand() % (n - 1) + 1;
        LL x = quick_mod(a, m, n);
        LL y = 0;
        for(int j=0; j<k; j++)
        {
            y = multi(x, x, n);
            if(y == 1 && x != 1 && x != n - 1) return false;
            x = y;
        }
        if(y != 1) return false;
    }
    return true;
}

int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        LL n;
        scanf("%I64d",&n);
        if(Miller_Rabin(n)) puts("Yes");
        else puts("No");
    }
    return 0;
}

```
质数检测Java大数版：

``` java
import java.io.*;
import java.util.*;
import java.math.BigInteger;
 
public class Main{
	    public static final int Times = 10;
	    
	    public static BigInteger quick_mod(BigInteger a,BigInteger b,BigInteger m){
	    		BigInteger ans = BigInteger.ONE;
	    		a = a.mod(m);
	    		while(!(b.equals(BigInteger.ZERO))){
	    				if((b.mod(BigInteger.valueOf(2))).equals(BigInteger.ONE)){
	    						ans = (ans.multiply(a)).mod(m);
	    						b = b.subtract(BigInteger.ONE);
	    				}
	    				b = b.divide(BigInteger.valueOf(2));
	    				a = (a.multiply(a)).mod(m);
	    		}
	    		return ans;
	    }
	    
	 	public static boolean Miller_Rabin(BigInteger n){
	 			if(n.equals(BigInteger.valueOf(2))) return true;
	 			if(n.equals(BigInteger.ONE)) return false;
	 			if((n.mod(BigInteger.valueOf(2))).equals(BigInteger.ZERO)) return false;
	 			BigInteger m = n.subtract(BigInteger.ONE);
	 			BigInteger y = BigInteger.ZERO;
	 			int k = 0;
	 			while((m.mod(BigInteger.valueOf(2))).equals(BigInteger.ZERO)){
	 					k++;
	 					m = m.divide(BigInteger.valueOf(2));
	 			}
	 			Random d = new Random();
	 			for(int i=0;i<Times;i++){
	 				    int t = 0;
	 				    if(n.compareTo(BigInteger.valueOf(10000)) == 1){
	 				    		t = 10000;
	 				    }else{
	 				    	    t = n.intValue() - 1;
	 				    }
	 					int a = d.nextInt(t) + 1;
	 					BigInteger x = quick_mod(BigInteger.valueOf(a),m,n);
	 					for(int j=0;j<k;j++){
	 							y = (x.multiply(x)).mod(n);
	 							if(y.equals(BigInteger.ONE) && !(x.equals(BigInteger.ONE)) && !(x.equals(n.subtract(BigInteger.ONE)))) return false;
	 							x = y;
	 					}
	 					if(!(y.equals(BigInteger.ONE))) return false;
	 			}
	 			return true;
	 	}
	 	
		public static void main(String[] args){
				Scanner cin = new Scanner(System.in);
				while(cin.hasNextBigInteger()){
						BigInteger n = cin.nextBigInteger();
						if(Miller_Rabin(n)) System.out.println("Yes");
						else System.out.println("No");
				}
		}
}
 
```






### 素数的筛选（构造素数表）
不采用筛素：假设我们已经我素数序列: p1, p2, .. pn
现在要判断pn+1是否是素数, 则需要(1, sqrt(pn+1)]范围内的所有素数序列,
而这个素数序列显然已经作为p1, p2, .. pn的一个子集被包含了

``` cpp
void makePrimes(int primes[], int num)
{
	int i, j, cnt;

	primes[0] = 2;
	primes[1] = 3;

	for(i = 5, cnt = 2; cnt < num; i += 2)
	{
		int flag = true;
		for(j = 1; primes[j]*primes[j] <= i; ++j)
		{
			if(i%primes[j] == 0)
				{
					flag = false; break;
				}
		}
		if(flag) primes[cnt++] = i;
	}
}
```


可以使用筛素法，复杂度`O(nloglogn)`：

``` cpp
bool prime[N];
void init(){
    for(int i = 2; i < N; i ++) prime[i] = true;
    for(int i = 2; i*i < N; i ++){//判断改成i*i<N 
        if(prime[i]){
            for(int j = i*i; j < N; j += i){//从i*i开始就可以了 
                prime[j] = false;  
            }
        }
    }
}
```
或者采用线性筛素法`O(n)`：

``` cpp
#include<cstdio>
const int N = 100000 + 5;
bool prime[N];//prime[i]表示i是不是质数 
int p[N], tot;//p[N]用来存质数 
void init(){
    for(int i = 2; i < N; i ++) prime[i] = true;//初始化为质数 
    for(int i = 2; i < N; i++){
        if(prime[i]) p[tot ++] = i;//把质数存起来 
        for(int j = 0; j < tot && i * p[j] < N; j++){
            prime[i * p[j]] = false;
            if(i % p[j] == 0) break;//保证每个合数被它最小的质因数筛去 
        }
    }    
}
int main(){
    init();
}
```



### 素数的性质

### 幂乘快速计算（二分思想）
逆向思维，不断地二分，累积底数的平方即可：

``` cpp
typedef long long LL;

LL pow_mod(LL a, LL b, LL p){//a的b次方求余p 
    LL ret = 1;
    while(b){
        if(b & 1) ret = (ret * a) % p;
        a = (a * a) % p;
        b >>= 1;
    }
    return ret;
}
```
衍生出ll的快速乘：

``` cpp
LL mul(LL a, LL b, LL p){//快速乘，计算a*b%p 
    LL ret = 0;
    while(b){
        if(b & 1) ret = (ret + a) % p;
        a = (a + a) % p;
        b >>= 1;
    }
    return ret;
}
```
关于计算结果过除以MOD取余的问题：
1、计算加法每相加一次执行一次取余；
2、计算减法给被减数加上MOD之后先减法后取余；
3、计算乘法每相乘一次取余一次。

### GCD&LCM的相关
计算gcd循环写法和递归写法：

``` cpp
LL gcd(LL a, LL b){
    if(b == 0) return a;
    else return gcd(b, a%b);
}

LL gcd(LL a, LL b){
    return b ? gcd(b, a%b) : a;
}

LL gcd(LL a, LL b){
    LL t;
    while(b){
        t = b;
        b = a % b;
        a = t;
    }
    return a;
}
```
相关的公式：

``` stylus
a*b = gcd(a,b) * lcm(a,b)
gcd(ka, kb) = k * gcd(a, b)
lcm(ka, kb) = k * lcm(a, b)
lcm(S/a, S/b) = S/gcd(a, b)
```

### 扩展欧几里德算法
那么已知 a，b 求 一组解 x，y 满足 ax+by = gcd(a, b) 这个公式:

![enter description here][1]

代码模板：
 
``` cpp
#include<cstdio>
typedef long long LL;
void ex_Eulid(LL a, LL b, LL &x, LL &y, LL &d){
    if (!b) {d = a, x = 1, y = 0;}
    else{
        extend_Eulid(b, a % b, y, x, d);
        y -= x * (a / b);
    }
}
int main(){
    LL a, b, d, x, y;
    while(~scanf("%lld%lld", &a, &b)){
        ex_Eulid(a, b, x, y, d);
        printf("%lld*a + %lld*b = %lld\n", x, y, d);
    }
}
```

### 威尔逊定理
当且仅当p为素数时：( p -1 )! ≡ -1 ( mod p )
或者这么写( p -1 )! ≡ p-1 ( mod p )
若p为质数，则p能被(p-1)!+1整除
在初等数论中，这是威尔逊给出了判定一个自然数是否为素数的充分必要条件。

### 欧拉定理
欧拉定理，也称费马-欧拉定理
若n,a为正整数，且n,a互质，即gcd(a,n) = 1，则a^φ(n) ≡ 1 (mod n)
 
φ(n) 是欧拉函数，欧拉函数是求小于等于n的数中与n互质的数的数目  
欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目或者说欧拉函数是求 1到n-1 中 与n互质的数的数目。
 
如果n是质数那么1到n-1所有数都是与n互质的，所以φ(n) = n-1

### 中国剩余定理
![CRT问题描述][2]

CRT问题代码描述如下：

``` cpp
void extend_Euclid(LL a, LL b, LL &x, LL &y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return;
    }
    extend_Euclid(b, a % b, x, y);
    LL tmp = x;
    x = y;
    y = tmp - (a / b) * y;
}

int CRT(int a[],int m[],int n)
{
    int M = 1;
    int ans = 0;
    for(int i=1; i<=n; i++)
        M *= m[i];
    for(int i=1; i<=n; i++)
    {
        int x, y;
        int Mi = M / m[i];
        extend_Euclid(Mi, m[i], x, y);
        ans = (ans + Mi * x * a[i]) % M;
    }
    if(ans < 0) ans += M;
    return ans;
}
```


### 费马小定理
假如p是质数：
若p不能整除a，则 a^(p-1) ≡1（mod p）；
若p能整除a，则a^(p-1) ≡0（mod p）。
或者说，若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。


  [1]: ./images/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97.png "扩展欧几里得.png"
  [2]: ./images/crt.png "crt.png"