---
title: 排序学习小结 
tags: 排序
grammar_cjkRuby: true
---

**整理与数据结构与算法分析、算法导论**
**一意専心**

- 这里讨论的排序默认可以在主存内完成，当数据量过大时需要在外部存储介质中完成的排序称为**外部排序**。
- 我们假定数据为整数，或者是存在着偏序关系的数据集。这种条件下称为**基于比较的排序**。

- 针对简单排序复杂度，例如冒泡、选择、插入等，有：
> 定理：n个互异数的数组的平均逆序数是`n(n-1)/4`.（反序表证明）
> 定理：通过**交换相邻元素**进行的排序的任何算法平均需要O(n^2)。


#### 插入排序
算法描述：对于n个元素排序，走n-1次pass，对于位置i，假定0-i-1的元素均有序，第i号位的元素从后查找插入合适的位置即可。

属于**稳定排序**,复杂度**O(n^2)**。
``` c
void InsertionSort(int* array,int n)
{
	int j,tmp;
	for(int i=1;i<n;i++)
	{
		tmp=array[i];
		for(j=i;j>0 && array[j-1]>tmp;j--)
			array[j]=array[j-1];
		array[j]=tmp;
	}
}
```



#### 希尔排序
算法描述：又称为**缩小增量排序**，给定增量序列{h}，按增量序列每个h个的元素划分为一组，对每一组分别执行一次插入排序，直至增量为1即可。

默认的**增量序列是{[x=n/2]|x>0&&x=x/2}**，即n/2向下取整。

属于**不稳定排序**，平均复杂度**O(n^2)**，复杂度与增量序列有关，最好优化可到O(n^1.2)左右，中小规模数据量时性能好，最坏情况与平均情况差不多。

``` c
void Swap(int& a,int& b)
{
	int tmp;
	tmp=a;
	a=b;
	b=tmp;
}
void ShellSort(int* a, int n)  
{  
    int i,j,gap;  
  
    for (gap=n/2;gap>0;gap/=2)  
        for(i=gap;i<n;i++)  
            for(j=i-gap;j>=0&&a[j]>a[j+gap];j-=gap)  
                Swap(a[j],a[j+gap]);  
}  
```

> 希尔排序性能分析
- 增量序列的选择
① 最后一个增量必须为1；
② 应该尽量避免序列中的值(尤其是相邻的值)互为倍数的情况。
有人通过大量的实验，给出了较好的结果：当n较大时，比较和移动的次数约在nl.25到1.6n1.25之间。
- Shell排序的时间性能优于直接插入排序
①当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。
②当n值较小时，n和  的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0(n^2)差别不大。
③在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。
- 综上，希尔排序由于比较步长从大到小，即**不是基于相邻元素比较**，因而在一定数据规模时，性能可以**突破O(n^2)**。
